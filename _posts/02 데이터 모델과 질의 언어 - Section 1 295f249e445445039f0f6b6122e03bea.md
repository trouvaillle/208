# 02. 데이터 모델과 질의 언어 - Section 1

author: 최현섭
announced_on: 2024년 7월 16일

# #2 데이터 모델과 질의 언어

- 데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐만 아니라 해결하려는 **문제를 어떻게 생각해야 하는지**에 대해서도 지대한 영향을 미친다.
- 데이터 모델은 그 위에서 소프트웨어가 할 수 있는 일과 할 수 없는 일에 지대한 영향을 주므로 **애플리케이션에 적합한 데이터 모델을 선택하는 작업은 상당히 중요하다.**

## **관계형 모델과 문서 모델**

- 오늘날 가장 잘 알려진 데이터 모델 => 관계형 모델
    - 1970년 에드가 코드(Edgar Codd)가 제안
    - **데이터는 관계로 구성되고 각 관계는 순서 없는 튜플의 모음**
    - 초반에는 별 관심 없다가 1980년부터 대중적으로 사용
- 관계형 데이터베이스의 근원
    - 1960~1970년대 일반적인 비즈니스 데이터 처리에서 사용. ex: 트랜잭션 처리(은행 거래, 예약 등등), 일괄처리(급여 등등)
    - 중간중간 네트워크 모델, 계층 모델, 객체 데이터 베이스, XML 데이터베이스 등등이 채택된경우도 있지만 결국 관계형 모델이 우위를 가져갔다.
    - 컴퓨터가 훨씬 더 강력해지고 네트워크화됨에 따라 관계형 모델은 본래 비즈니스 데이터 처리라는 본래 영역을 넘어 폭 넓은 다양한 사용 사례에서도 보편화됨. ex: 온라인 쇼핑몰, 게임 등등
    - 당시 다른 데이터베이스를 사용하는 애플리케이션 개발자는 데이터베이스의 내부 데이터 표현에 대해 많이 고민해야 했지만 **관계형 모델의 목표는 정리된 인터페이스 뒤로 구현 세부 사항을 숨기는 것이다.**

### **NoSQL의 탄생**

- 2010년대에 들어서면서 NoSQL이 관계형 모델의 라이벌로 등장
- NoSQL 용어 자체는 오픈소스, 분산환경, 비관계형 데이터베이스 밋업 용으로 사용한 인기 트위터 해시태그 였지만, 해당 용어가 비관계형 데이터베이스 시스템과 엮이면서 Not Only SQL로 재해석 됨
- NoSQL이 채택된 다양한 원동력
    - 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성 필요
    - 상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
    - 관계형 모델에서 지원하지 않는 특수 질의 동작
    - 관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람
- 다중 저장소 지속성(polyglot persistence)
    - 한 사용 사례에 맞는 최적의 기술 선택은 또 다른 사례에 맞는 최적의 선택과는 다를 수 있음.
    - 가까운 미래에는 관계형 데이터베이스가 폭넓은 다양함을 가진 비관계형 데이터스토어와 함께 사용될 것. 이런 개념을 **다중 저장소 지속성** 이라고한다.

### **객체 관계형 불일치**

- 임피던스 불일치(Impedance mismatch)
    - 객체지향 애플리케이션 데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터 베이스 모델 객체 사이에 거추장스러운 계층이 필요하다.
    - ActiveRecord, Hibernate 같은 객체 관계형 매핑(ORM) 프레임워크를 사용하면 보일러플레이트 코드의 양을 줄일 수 있지만 두 모델 간의 차이를 완벽히 숨길수는 없다.
    - 이런 모델사이의 분리를 종종 **임피던스 불일치**라고 부른다.

`아래 프로필 구성할 관계형 데이터 모델을 구성하는 방법`

1. 전통적인 SQL 모델에서 가장 일반적인 정규화 표현은 직위, 학력, 연락처 정보를 개별 테이블에 넣고, 외래 키로 `users` 테이블을 참조한다.
2. SQL 표준의 마지막 버전에서 구조화된 데이터타입과 XML 데이터에 대한 지원을 추가했음. 이 지원으로 단일 로우에 다중 값을 저장할 수 있고 문서 내 질의와 색인이 가능해짐. (오라클, DB2, PostgresSQL, MSSQL에서 지원)
3. 직업, 학력, 연락처 정보를 JSON이나 XML문서로 변환해 데이터베이스의 텍스트 칼럼에 저장한 다음 애플리케이션이 구조와 내용을 해석하게 하는 방법. 이 방식은 칼럼의 값을 질의할때 데이터베이스를 사용할 수 없다.

- 이력서같은 데이터 구조는 모든 내용을 갖추고 있는 문서라서 JSON 표현에 매우 적합하다.
- MongoDB, RethinkDB, CouchDB, Espresso 같은 문서 지향 데이터베이스는 JSON모델을 지원한다.

```json
# 위 프로필 데이터를 json 문서로 표현했을때
{
 "user_id": 251,
 "first_name": "Bill",
 "last_name": "Gates",
 "summary": "Co-chair of the Bill & Melinda Gates... Active blogger.",
 "region_id": "us:91",
 "industry_id": 131,
 "photo_url": "/p/7/000/253/05b/308dd6e.jpg",
 "positions": [
   {"job_title": "Co-chair", "organization": "Bill & Melinda Gates Foundation"},
   {"job_title": "Co-founder, Chairman", "organization": "Microsoft"}
 ],
 "education": [
   {"school_name": "Harvard University", "start": 1973, "end": 1975},
   {"school_name": "Lakeside School, Seattle", "start": null, "end": null}
 ],
 "contact_info": {
   "blog": "http://thegatesnotes.com",
   "twitter": "http://twitter.com/BillGates"
 }
}
```

- 다중테이블 vs JSON
    - JSON은 관계형 데이터베이스의 다중 테이블 스키마보다 더 나은 **지역성**을 가진다.
    - 위 예제의 프로필 데이터를 구성하려면 다중 테이블은 `user_id` 기준으로 다중 질의를 하거나 조인을 해야하지만 JSON은 모든 관련 정보가 한 곳에 있어 질의 하나로 충분하다.
- 사용자 프로필에서 직위, 학력 기록, 연락처 정보로 대응되는 일대다 관계는 의미상 데이터 트리 구조와 같다.이 트리 구조는 JSON 표현에서 명시적으로 드러난다.

### **다대일과 다대다 관계**

- `region_id` 와 `industry_id`가 평문이 아니라 id로 매핑되는 이유
    - region과 industry를 평문으로 받지 않고 드롭다운 리스트로 만들경우 장점
        - 프로필 간 일관된 스타일과 철자
        - 모호함 회피
        - 갱신의 편의성
        - 다국적 언어 지원
        - 더 나은 검색. 예를 들어 워싱턴 주에 있는 자선가를 검색하려 할때 지역 목록에 시애틀이 워싱턴에 있다는 사실을 부호화할 수 있기 때문에 원하는 프로필을 더 잘 찾을 수 있음. (시애틀로 검색했을때 워싱턴을 식별할 수 없음)
        - 텍스트간 중복을 피할 수 있음
    - 사용자 입력 텍스트를 그대로 저장하는경우 위 모든 장점을 뺐긴다.
    - 만약 정보가 중복되어있다면 모든 중복 항목을 변경해야하는데 이것은 쓰기 오버헤드와 불일치(정보의 일부 중복은 갱신됐지만 다른 중복 항목이 갱신안됨) 위험이 있다. 이런 중복을 제거하는 일이 **데이터베이스의 정규화 이면에 놓인 핵심 개념**이다.
- 문서 모델과 다대일 관계
    - 중복된 데이터를 정규화하려면 다대일 관계가 필요한데 안타깝게도 다대일 관계는 문서 모델에 적합하지 않다.
    - 문서 데이터베이스는 단일 row에서 1:N 을 구현할 수 있기 때문에 일반적으로 조인이 필요하지 않고 조인이 지원되는 경우도 많지 않다.
    - 데이터베이스 자체가 조인을 지원하지 않으면 데이터베이스에 대한 다중 질의를 만들어서 애플리케이션에서 조인을 흉내내야한다.
    - 애플리케이션 초기 버전에는 조인 없는 문서 모델에 적합하더라도 애플리케이션에 기능을 추가하면서 데이터가 상호 연결되는 경향이 있다.
        1. 더 많은 정보 표현하기
            - 프로필 데이터베이스의 `organization`과 `school_name`은 문자열이었다.
            - 이 두 프로퍼티를 엔티티로 참조하면 각 이력서에 조직과 학교로 연결하는 링크를 포함하거나 조직의 로고 및 추가 정보를 포함할 수 있다.
        2. 추천서 기능
            - 새로운 기능으로 한 사용자가 또다른 사용자를 위해 추천서를 작성하는 기능을 넣는다고 해보자.
            - 추천서는 추천받은 사용자 이력서에 추천인의 이름과 사진이 함께 보여진다.
            - 추천인이 자신의 사진을 갱신하면 추천인이 작성한 모든 추천서에 새로운 사진을 반영해야하므로 추천서는 작성자 프로필을 참조해야 한다.

### **문서 데이터베이스는 역사를 반복하고 있나?**

- IBM의 정보 관리 시스템(Information Management System, IMS)
    - 1970년대 비즈니스 데이터 처리를 위한 가장 많이 사용한 데이터베이스
    - IMS의 설계는 **계층 모델**이라 부르는 상당히 간단한 데이터 모델을 사용한다.(지금 JSON과 매우 흡사)
    - 문서 데이터베이스처럼 IMS도 일대다 관계에서는 잘 동작하지만 다대다 관계 표현은 어렵고 조인도 지원하지 않는다. 개발자는 데이터를 중복할지, 한 레코드와 또 다른 레코드의 참조를 수동으로 해결할지 결정해야 했는데 이문제는 1970년대와 오늘날 문서 데이터베이스를 사용하는 개발자가 풀어야할 문제와 매우 비슷하다.
    - 계층 모델의 한계를 해결하기위해 **관계형 모델**, **네트워크 모델**이 등장했다.

### 네트워크 모델

- 코다실(Conference on Data Systems Languages, CODASYL)이라 불리는 위원회에서 표준화함(네트워크 모델을 코다실 모델이라고도 부름)
- 계층모델의 트리 구조에서 모든 레코드는 정확하게 하나의 부모가 있지만 **네트워크 모델에서 레코드는 다중 부모**가 있을 수 있다.
- 레코드에 접근하는 유일한 방법은 최상위 레코드에서부터 연속된 연결 경로를 따르는 방법이다. 이를 **접근 경로**라한다.
- 코다실 모델에서의 질의는 레코드 목록을 반복해 접근 경로를 따라 데이터베이스의 끝에서 끝까지 커서를 움직여 수행한다. 만약 레코드가 다중 부모를 가진 상태라면 애플리케이션 코드는 다양한 관계를 모두 추적해야 한다.
- 수동 접근 경로 선택은 1970년대에는(탐색이 매우 느린 테이프 드라이브와 같이) 매우 제한된 하드웨어 성능을 가장 효율적으로 사용할 수 있었지만 데이터베이스 질의와 갱신을 위한 코드가 복잡하고 유연하지 못한 문제가 있었다.
- 계층 모델과 네트워크 모델 모두 원하는 데이터에 대한 경로가 없다면 접근 경로를 변경할 수 있지만 아주 많은 수작업 데이터베이스 질의 코드를 살펴봐야하고 새로운 접근 경로를 다루기 위해 재작성해야 한다. 애플리케이션의 데이터 모델을 바꾸는 작업은 매우 어려운 일이었다.

### 관계형 모델

- 네트워크모델과 대조적인 관계형 모델이 하는 일은 **알려진 모든 데이터를 배치**하는 것이다.
- 얽히고설킨 중첩 구조와 데이터를 보고 싶을 때 따라가야 할 복잡한 접근 경로가 없다.
- 임의 조건과 일치하는 테이블의 일부 또는 모든 로우를 선택해서 읽을 수 있고 일부 칼럼을 키로 지정해 칼럼과 일치하는 특정 로우를 읽을 수 있다.
- 다른 테이블과의 외래 키 관계에 대해 신경쓰지 않고 임의 테이블에 새 로우를 삽입할 수 있다.
- 관계형 데이터베이스에서 **옵티마이저**는 질의의 어느 부분을 어떤 순서로 실행할지를 결정하고 사용할 색인을 자동으로 결정한다.
- 이 선택은 실제로 접근 경로지만, 큰 차이점은 애플리케이션 개발자가 아니라 **옵티마이저가 접근경로를 자동으로 만든다는 점**이다.
- 새로운 방식으로 데이터에 질의하고 싶은 경우 새로운 색인을 선언하기만 하면 질의는 자동으로 가장 적합한 색인을 사용한다. 따라서 관계형 모델은 애플리케이션에 새로운 기능을 추가하는 작업이 훨씬 쉽다.

### 문서 데이터베이스와의 비교

- 문서 데이터베이스는 별도 테이블이 아닌 상위 레코드 내에 중첩된 레코드를 저장한다. (일대다 관계)
- 다대일과 다대다 관계를 표현할 때 관계형 데이터베이스와 문서 데이터베이스는 근본적으로 다르지 않다.
- 관계형 모델에서는 **외래키**라 부르고 문서 모델에서는 **문서 참조**라 부른다.
- 이 식별자는 조인이나 후속 질의를 사용해 읽기 시점에 확인한다.

### **관계형 데이터베이스와 오늘날의 문서 데이터베이스**

- 문서 데이터 모델을 선호하는 주요 이유는 **스키마 유연성**, **지역성**에 기인한 더 나은 성능때문이고 일부 애플리케이션의 경우 애플리케이션에서 사용하는 데이터 구조와 더 가깝기 때문이다.
- 관계형 모델은 조인, 다대일, 다대다 관계를 더 잘 지원함으로써 문서 데이터 모델에 대항한다.

### 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?

- 애플리케이션에서 데이터가 문서와 비슷한 구조라면 문서 모델을 사용하는 것이 좋다.
- 문서와 비슷한 구조를 여러 테이블로 나누어 찢는 관계형 기법은 다루기 힘든 스키마와 불필요하게 복잡한 애플리케이션 코드를 발생시킨다.
- 문서 데이터베이스의 미흡한 조인 지원은 애플리케이션에 따라 문제일 수도 있고 아닐수도 있다. 예를들어 append만 하는 이벤트 애플리케이션에서는 다대다 관계가 결코 필요하지 않다.
- 애플리케이션에서 다대다 관계를 사용한다면 문서 모델의 매력은 떨어진다.
- 비정규화로 조인의 필요성 줄이기가 가능하지만 애플리케이션 코드는 비정규화된 데이터의 일관성을 유지하기 위해 추가 작업을 해야한다.
- 조인은 애플리케이션 코드에서 다중 요청을 만들어 흉내낼 수 있지만 데이터베이스 조인보다 속도가 느리고, 애플리케이션의 복잡도가 증가한다.
- **일반적으로 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 만드는지 말할 수 없다. 데이터 항목간에 존재하는 관계 유형에 따라 다르다.**

### 문서 모델에서의 스키마유연성

- 문서 데이터베이스는 종종 **스키마리스**로 불리지만 이는 오해의 소지가 있다.
- 쓰기 스키마와 읽기 스키마
    - 쓰기 스키마(스키마): 관계형 데이터베이스의 전통적인 접근 방식. 스키마는 명시적이고 데이터 베이스는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장한다.
    - 읽기 스키마(스키마 리스): 데이터 구조는 암묵적이고 데이터를 읽을때만 해석된다.
    - 읽기 스키마는 프로그래밍 언어에서 **동적 타입 확인**과 유사하고 쓰기 스키마는 **정적 타입 확인**과 비슷하다.
    - 데이터베이스 스키마 강제는 논쟁의 여지가 있는 주제이며 일반적으로 옳고 그른 정답은 없다.
- 문서 데이터베이스는 데이터를 읽는 코드에서 구조의 유형을 어느정도 가정한다 (읽기 스키마)
- 접근 방식 간 차이는 애플리케이션이 데이터 타입을 변경하고자 할 때 특히 뚜렷이 나타난다
    - 예제: 하나의 필드에 사용자의 전체 이름을 저장하고 있지만 성과 이름을 분리해서 저장&사용하고 싶은 경우
        - 문서 데이터베이스 (읽기 스키마, 동적 타입)
            - 문서 데이터베이스에서는 새로운 필드를 가진 새로운 문서를 작성하기 시작하고 애플리케이션에서는 예전 문서를 읽은 경우를 처리하는 코드만 있으면 된다.
            
            ```jsx
            if (user && user.name && !user.first_name) { 
              // 2013년 12월 8일 이전에 쓴 문서는 first_name이 없음 
              user.first_name = user.name.split(" ")[0];
            }
            ```
            
        - 관계형 데이터베이스 (쓰기 스키마, 정적 타입)
            - 정적 타입의 데이터베이스 스키마에서는 보통 아래와 같이 마이그레이션을 수행한다.
            - `ALTER TABLE users ADD COLUMN fist_name text;UPDATE users SET first_name = split_part(name, ' ', 1) // PostgreSQLUPDATE users SET first_name = substring_index(name, ' ', 1) // MySQL`
            - 스키마는 변경이 느리고 중단시간을 요구하기 때문에 평판이 나쁘지만 대부분의 관계형 데이터베이스 시스템은 ALTER TABLE 문을 수 밀리초 안에 수행한다. (MySQL은 예외적으로 ALTER TABLE시에 전체 테이블을 복사)
            - 만약 큰 테이블에 UPDATE문을 실행하면 모든 로우가 재작성될 수 있기 때문에 이 방식을 수용할 수 없다면 읽기 스키마와 동일한 방식으로 읽는 시점에 값을 채울 수 있다.
- 읽기 스키마 vs 쓰기 스키마
    - 읽기 스키마 접근 방식은 컬렉션 안의 항목이 어떤 이유로 모두 동일한 구조가 아닐 때 유리하다.
        - 다른 여러 유형의 오브젝트가 있고 각 유형의 오브젝트별로 자체테이블에 넣는 방법은 실용적이지 않다.
        - 사용자가 제어할 수 없고 언제나 변경 가능한 외부 시스템에 의해 데이터 구조가 결정된다.
    - 모든 레코드가 동일한 구조라서 예상 가능하다면 쓰기 스키마가 문서화와 구조를 강제하기 위한 유용한 매커니즘이다.

### 질의를 위한 데이터 지역성

- 웹 페이지 상에 문서를 보여주는 동작처럼 애플리케이션이 자주 전체 문서에 접근해야 할 때 **저장소 지역성**을 활용하면 성능 이점이 있다.
- 만약 노출해야할 데이터가 다중 테이블로 나눠졌으면 전체를 검색하기 위해 다중 색인 검색이 필요하다. 이 경우 더 많은 디스크 탐색이 필요하고 더 많은 시간이 소요된다.
- 지역성의 이점 => **한 번에 해당 문서의 많은 부분을 필요로 하는 경우에만 적용된다.**
- 문서의 크기가 작아야하는 이유
    - 데이터베이스는 대개 문서의 작은 부분에만 접근해도 전체 문서를 적재해야 하기에 큰 문서에서는 낭비일 수 있다.
    - 문서를 갱신할 때도 보통 전체 문서를 재작성해야 한다.
    - 이런 이유로 일반적으로 문서를 아주 작게 유지하면서 문서의 크기가 증가하는 쓰기를 피하라고 권장한다.
- 지역성을 위해 관련 데이터를 함께 그룹화하는 개념이 문서 모델에만 국한되지 않는다.
    - 구글의 스패너 데이터베이스: 부모 테이블 내에 테이블의 로우를 교차 배치되게끔 선언하는 스키마를 허용해 관계형 데이터 모델에서 지역성을 동일하게 제공
    - 오라클: 다중 테이블 색인 클러스터 테이블(multi-table index cluster table)
    - 칼럼 패밀리(colum-family) 개념 (카산드라와 HBase에서 사용)

> **Multi-Table Index Cluster Table이란?**
> 
> 
> Multi-Table Index Cluster Table은 여러 테이블의 데이터를 물리적으로 동일한 데이터 블록에 클러스터링하여 저장하는 오라클 데이터베이스의 스토리지 구조입니다. 이는 데이터를 공통의 컬럼 값을 기준으로 클러스터링하여 저장함으로써, 관련 데이터를 물리적으로 가까이 배치하여 효율적인 데이터 접근을 가능하게 합니다.
> 
> ### **주요 특징**
> 
> 1. **공통 키를 통한 클러스터링**:
>     - 여러 테이블이 공통의 키 컬럼을 가지고 있을 때, 이 공통 키를 기반으로 데이터를 클러스터링하여 저장합니다. 예를 들어, 고객 정보와 주문 정보가 고객 ID를 통해 클러스터링될 수 있습니다.
> 2. **효율적인 데이터 접근**:
>     - 공통 키를 기준으로 관련 데이터를 함께 저장하기 때문에 조인 연산 시 I/O 작업이 줄어들어 성능이 향상됩니다. 이는 특히 대량의 데이터를 조인할 때 유용합니다.
> 3. **공유 인덱스**:
>     - 클러스터 인덱스를 사용하여 데이터를 검색합니다. 클러스터 인덱스는 클러스터링된 테이블들의 공통 키 컬럼을 기반으로 생성되며, 이 인덱스를 통해 관련 데이터를 효율적으로 검색할 수 있습니다.
> 4. **데이터 중복 최소화**:
>     - 공통 키를 기준으로 데이터를 클러스터링하므로, 동일한 키를 여러 번 저장하지 않고도 데이터를 관리할 수 있어 저장 공간이 절약됩니다.
> 
> ### **장점**
> 
> - **조인 성능 향상**: 관련 데이터가 물리적으로 근접하게 저장되어 조인 연산의 성능이 향상됩니다.
> - **저장 공간 절약**: 공통 키 컬럼을 중복 저장하지 않아 저장 공간을 절약할 수 있습니다.
> - **효율적인 I/O**: 관련 데이터가 동일한 블록에 저장되므로 디스크 I/O 작업이 줄어듭니다.
> 
> ### **단점**
> 
> - **복잡한 관리**: 여러 테이블의 데이터를 동일한 클러스터에 저장하므로 테이블의 생성 및 관리가 복잡할 수 있습니다.
> - **업데이트 비용**: 클러스터링된 테이블의 데이터를 업데이트할 때 더 많은 비용이 들 수 있습니다.
> 
> ### **칼럼 패밀리란?**
> 
> 칼럼 패밀리는 카산드라의 데이터 모델에서 테이블과 유사한 개념입니다. 기본적으로 키-값 스토어의 확장으로, 데이터를 행(row)과 칼럼(column) 형태로 저장합니다. 각 칼럼 패밀리는 여러 행을 포함하고, 각 행은 고유한 행 키(row key)로 식별됩니다.
> 
> ### **주요 특징**
> 
> 1. **유연한 스키마**:
>     - 각 행은 서로 다른 수의 칼럼을 가질 수 있습니다. 이는 스키마가 유연하여 다양한 형태의 데이터를 저장할 수 있다는 장점이 있습니다.
> 2. **데이터 분포**:
>     - 데이터는 행 키를 기준으로 분산 저장됩니다. 카산드라는 분산형 데이터베이스이기 때문에 데이터를 여러 노드에 분산하여 저장합니다. 이는 확장성과 가용성을 높여줍니다.
> 3. **복합 칼럼 지원**:
>     - 칼럼 패밀리는 단순한 기본형 칼럼뿐만 아니라 복합 칼럼(composite columns)도 지원합니다. 이는 복잡한 데이터 구조를 표현할 때 유용합니다.
> 
> ### **데이터 모델 예시**
> 
> 예를 들어, 사용자 정보와 사용자 활동 로그를 저장하는 칼럼 패밀리를 정의해보겠습니다.
> 
> ### 사용자 정보 칼럼 패밀리 (User Info Column Family)
> 
> | Row Key (user_id) | name | email | age |
> | --- | --- | --- | --- |
> | 1 | John Doe | mailto:john@example.com | 30 |
> | 2 | Jane Smith | mailto:jane@example.com | 25 |
> 
> ### 사용자 활동 로그 칼럼 패밀리 (User Activity Log Column Family)
> 
> | Row Key (user_id) | login_time | activity | details |
> | --- | --- | --- | --- |
> | 1 | 2024-07-15 10:00:00 | login |  |
> | 1 | 2024-07-15 10:05:00 | view_profile | viewed own profile |
> | 2 | 2024-07-15 11:00:00 | login |  |
> | 2 | 2024-07-15 11:10:00 | upload_photo | uploaded photo 'vacation.jpg' |

### 문서 데이터베이스와 관계형 데이터베이스의 통합

- 대부분의 관계형 데이터베이스 시스템은 XML과 JSON 문서에 대한 기능을 제공한다. 그래서 문서 데이터베이스를 사용할 때와 매우 비슷한 데이터 모델을 애플리케이션이 사용할 수 있다.
- 문서모델 역시 관계형 조인을 지원하고 있다.
- 관계형 데이터베이스와 문서 데이터베이스는 시간이 지남에 따라 점점 더 비슷해지고 있다.
- 만약 데이터 베이스가 데이터를 문서처럼 다룰 수 있고 관계형 질의를 수행한다면 애플리케이션은 필요에 따라 가장 적합한 기능을 조합해 사용하면된다.
- **관계형과 문서의 혼합 모델은 미래 데이터베이스들이 가야 할 올바른 길이다.**
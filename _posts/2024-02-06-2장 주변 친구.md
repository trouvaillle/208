---
layout: post
title:  "2장. 주변 친구"
date:   2024-02-06 00:00:00 +0900
categories: study books system-design-interview-vol2
announced_on: 2024년 2월 6일
author: 홍성민
---
‘1장 근접성 서비스’와 비슷하지만 큰 차이점은 주변 친구의 위치는 자주 바뀔 수 있다는 점이다.

# 1단계: 문제 이해 및 설계 범위 확정

설계 기작 전에 질문을 던져 설계 범위를 좁히는 과정이 필요하다.

가상 면접관과 질문하며 얻은 조건은 다음과 같다.

## 기능 요구사항

- 사용자는 모바일 앱에서 주변 친구를 확인할 수 있어야 한다. 주변 친구 목록에 보이는 각 항목에는 해당 친구까지의 거리, 그리고 해당 정보가 마지막으로 갱신된 시각이 함께 표시되어야 한다.
- 이 친구 목록은 몇 초마다 한 번씩 갱신되어 한다.

## 비기능 요구사항

- 낮은 지연 시간(low latency): 주변 친구의 위치 변화가 반영되는 데 너무 오랜 시간이 걸리지 않아야 한다.
- 안전성: 시스템은 전반적으로 안정적이어야 하지만 몇 개 데이터가 유실되는 정도는 용인할 수 있다.
- 결과적 일관성: 위치 데이터를 저장하기 위해 강한 일관성을 지원하는 데이터 저장소를 사용할 필요는 없다. 복제본의 데이터가 원본과 동일하게 변경되기까지 몇 초 정도 걸리는 것은 용인 가능하다

1. 주변에 대한 정의
    - 주변에 있다의 기준은 기본 값은 5마일이다. 이 수치는 설정 가능해야함
    - 두 사용자 간의 거리는 단순 직선거리로 가정함
2. 사용자
    - 예상 사용자 수
        - 10억명이 앱 사용자고 그 중 10% 정도가 주변 친구 찾기 기능을 활용한다 가정 → 1억명
    - 동시 접속 사용자 수
        - 동시 접속 사용자의 수는 일간 능동 사용자(DAU)  수의 10%로 가정 → 천만명
    - 친구 수
        - 평균적으로 한 사용자는 400명의 친구를 갖는다고 가정
3. 이동 이력 
    - 이력은 머신러닝 등 다양한 용도로 사용될 수 있어 저장
4. 주변친구 목록
    - 유효 시간
        - 친구 관계인 다른 사용자가 10분 이상 비활성 상태면 주변 친구 목록에서 지움
    - 페이지 당 20명의 주변 친구를 표시하고 사용자의 요청이 있으면 더 많은 주변 친구를 보여줌
5. 위치 갱신
- 30초 마다 자신의 위치를 갱신하면 충분

## 개략적 규모 측정

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter02/Untitled.png" | relative_url }})

# 2단계: 개략적 설계안 제시 및 동의 구하기

## 개략적 설계안

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter02/Untitled%201.png" | relative_url }})

### 로드밸런서

웹소켓 서버와 API 서버 앞단에 위치해서 부하 분산 역할을 한다.

### API 서버

무상태 API 서버의 클러스터로 친구 추가 / 삭제, 사용자 정보 갱신 등의 부가적인 작업을 처리하는 역할을 한다.

### 웹소켓 서버

친구 위치 정보 변경을 거의 실시간에 가깝게 처리하는 유상태 서버 클러스터다. 각 클라이언트(앱)는 이 중 한대와 웹소켓 연결을 지속적으로 유지한다. 

주변 친구의 위치가 변경되면 해당 정보를 클라이언트로 전송한다.

### 레디스

- 캐시 용
    - 위치 정보를 캐시하는데 사용한다.
- pub/sub 용
    - 초경량 메시지 버스로 새로운 채널을 생성하는 것은 아주 값싼 연산이다. 기가바이트급 메모리를 갖춘 레디스 서버는 수백만 개의 채널을 생성할 수 있다.
    - 레디스 pub/sub
        - 웹소켓 여러 대를 띄워둘 것이기 때문에 웹소켓서버에서 들어온 메시지를 다른 웹소켓 서버로 보내야해서 사용함
        
        ![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter02/Untitled%202.png" | relative_url }})
        
        - 해당 사용자의 친구 각각과 연결된 웹소켓 연결 핸들러는 해당 채널의 구독자로 설정되어있다. 특정 사용자의 위치가 바뀌면 해당 사용자의 모든 친구의 웹소켓 연결 핸들러가 호출된다. 각 핸들러는 위치 변경 이벤트를 수신할 친구가 활성 상태면 거리를 다시 계산한다.

웹소켓 연결 핸들러 예시(코프링 기준~)

```kotlin
// 친구1, 친구2, 친구3
class FriendMessageHandler : WebSocketHandler {
    override fun handleMessage(session: WebSocketSession, message: WebSocketMessage<*>) {
        // 위치 변경 메시지 수신 시 조건을 확인하고 해당 친구가 자신의 정보를 받을 수 있는 조건인 경우 보낸다.
    }
.. 중략
}
```

### 사용자 DB

사용자의 친구 관계 정보를 저장한다.

### 위치 이동 이력 DB

머신러닝 등에 활용하기 위해 이력 저장 용으로 사용한다. 

## 친구에게 위치 변경 내역 전송 시나리오

  

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter02/Untitled%203.png" | relative_url }})

 1. 사용자 1의 위치가 변경되면 그 변경 내역은 사용자 1과의 연결을 유지하고 있는 웹소켓 서버에서 전송된다.

1. 해당 변경 내역은 레디스 pub/sub 서버 내의 사용자 1 전용 채널로 발행된다.
2. 레디스 pub/sub 서버는 해당 변경 내역을 모든 구독자에게 브로드캐스트한다. 이때 구독자는 사용자 1과 친구 관계에 있는 모든 웹소켓 연결 핸들러다
3. 위치 변경 내역을 보낸 사용자와 구독자 사이의 거리, 즉 이 경우에는 사용자 1과 2사이의 거리가 검색 반경을 넘지 않을 경우 새로운 위치는 사용자2의 클라이언트로 전송된다.

## 데이터 모델

위치 정보 캐시와 이동 이력 데이터베이스를 알아본다.

### 위치 정보 캐시

위치 정보 캐시는 ‘주변 친구’ 기능을 켠 활성 상태 친구의 가장 최근 위치를 보관한다. 여기서는 레디스를 사용한다. 읽기 및 쓰기 연산속도가 빠르고 ttl 기능이 있기 때문이다. 해당 캐시에 보관될 키/값 쌍은 다음과 같은 형태다.

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter02/Untitled%204.png" | relative_url }})

### 위치 이동 이력 데이터베이스

다음 스키마를 따르는 테이블에 저장한다.

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter02/Untitled%205.png" | relative_url }})

막대한 쓰기 연산부하를 감당할 수 있고 수평적 규모 확장이 가능한 데이터베이스다. 카산드라는 그런 요구에 잘 부합한다. 관계형 DB를 사용한다면 user_id를 샤딩키로 잡아서 관리하는 것이 일반적이다.

# 3단계: 상세 설계

이번 절에서는 규모를 늘려 나가면서 병목 및 그 해결책을 찾는 데 집중하도록 한다.

## 중요 구성요소별 규모 확장성

### API 서버

CPU 사용률이나 부하, I/O 상태에 따라 자동으로 늘리면된다. (오토스케일링)

서버를 다시 죽일 때 기존 요청이 끝나기까지 기다리는 정책을 만들고 지키면 될 것임

### 웹소켓 서버

웹소켓 서버는 유상태 서버라 기존 서버를 제거할 때 더 주의해야 한다. 노드를 실제로 제거하기 전에 우선 기존 연결부터 종료될 수 있도록 한다. 이를 위해, 로드밸런서가 인식하는 노드 상태를 연결종료 중으로 변경해 둔다. 그러면 그 서버로는 새로운 웹소켓 연결이 만들어지지 않는다. 그리고 모든 연결이 종료되면 서버를 제거한다.

클라우드 로드밸런서는 이런 일을 잘 처리한다. 

제거된 웹소켓 서버를 사용하던 클라이언트는 웹소켓 연결이 끊어질테니 로드밸런서를 통해 새로운 웹소켓 서버에 연결되어야 한다.

### 클라이언트 초기화

웹소켓 연결이 초기화되면 클라이언트는 해당 모바일 단말의 위치를 전송한다. 위치 정보를 받은 웹소켓 연결 핸들러는 다음 작업을 수행한다.

1. 위치 정보 캐시의 사용자 위치를 갱신
2. 사용자 데이터베이스에서 사용자 친구 정보를 읽음
3. 위치 정보 캐시(레디스)에 벌크로 친구들 정보를 읽음. 여기에 나오지 않는 친구들의 위치정보는 ttl이 지나 삭제된 거임 제외하면됨
4. 친구들 각각의 위치정보를 보고 거리 계산한다. 거리가 기준 이내이면 친구의 상세 정보와 위치, 생성시간을 앱으로 보내준다
5. 각 친구의 위치 채널을 구독한다. 활성화되지 않은 채널은 CPU나 I/O를 전혀 이용하지 않고 채널 생성 오버헤드가 적고 메모리도 적게 사용하고 있기 때문에 모든 친구의 채널을 구독하는 방법을 추천함(레디스에 위치 정보가 있는 즉 활성화된 친구가 아니라도 일단 채널 다 만듬)
6.  사용자의 현재 위치를 레디스 pub/sub 서버의 전용 채널을 통해 모든 친구에게 전송한다.

### 사용자 데이터베이스

사용자 정보와 친구 관계데이터를 저장한다. 관계형 데이터베이스를 사용하고 사용자 id를 기준으로 샤딩을 한다. 

관계데이터에도 샤딩이 필요하면 아래 처럼 1번 유저와 2번 유저가 친구가 된다면 2개의 row를 만들고 user_id 칼럼으로 샤딩을하면 될것 같음. (수평 확장이 가능하지만 친구관계 수정이 발생한 경우 관리가 더 번거로워질 수 있어 고민이 됨)

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter02/Untitled%206.png" | relative_url }})

친구관계에 설계에 대해 깊게 고민하고 싶다면 페이스북의 TAO 등을 참고하는게 좋을 듯.

[https://www.usenix.org/conference/atc13/technical-sessions/presentation/bronson](https://www.usenix.org/conference/atc13/technical-sessions/presentation/bronson)

### 위치 정보 캐시(레디스)

가용성을 높이려면 각 샤드에 보관하는 위치 정보를 대기 노드에 복제해 두면된다. 주 노드에 장애가 발생하면 대기 노드를 신속하게 주 노드로 승격시켜 장애시간을 줄인다.

### 레디스 pub/sub 서버

온라인 친구에게 보내는 위치 변경 내역 메시지의 라우팅 계층으로 활용한다. 새 채널은 구독하려는 채널이 없을 때 생성한다. 구독자가 없는 채널로 전송된 메시지는 그대로 버려진다. 그 과정에서 서버에 가해지는 부하는 거의 없다. 

1. 주변 친구 기능을 활용하는 모든 사용자에 채널 하나씩을 부여한다. 아울러 해당 기능을 사용하는 사용자의 앱은 초기화 시에 모든 친구의 채널과 구독 관계를 설정한다. 이때 친구의 상태는 개의치 않는다. 이렇게 하면 설계가 단순해진다. 활성화 상태로 바뀐 친구의 채널을 구독하거나 비활성 상태가 된 친구의 채널을 구독 중단하는 등의 작업을 할 필요가 없기 때문이다.
2. 한 가지 유의할 것은 더 많은 메모리를 사용하게 된다는 점이다. 그러나 메모리가 병목이 될 가능성은 낮다. 아키텍터를 단순하게 만들 수 있다면 더 많은 메모리를 투입할 만한 가치는 충분하다.

### 분산 레디스 pub/sub 서버 클러스터

서비스 탐색 컴포넌트를 도입하여 장애를 대비한다. 대표적인 예가 주키퍼이다. 

1. 가용한 서버 목록을 유지하는 기능 및 해당 목록을 갱신하는 데 필요한 UI나 API. 사실 서비스 탐색 소프트웨어는 설정 데이터를 보관하기 위한 소규모의 키-값 저장소라고 보면 된다. 

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter02/Untitled%207.png" | relative_url }})

1. 웹소켓 서버로 하여금 값에 명시된 레디스 pub/sub 서버에서 발생한 변경 내역을 구독할 수 있도록 하는 기능

1번 항목에서 언급한 키에 매핑된 값에는 활성 상태의 모든 레디스 pub/sub 서버로 구성된 해시 링을 보관한다. 레디스 pub/sub 서버는 메시지를 발행한 채널이나 구독 채널을 정해야할 때 이 해시 링을 참조한다.

예를 들어, 채널 2는 레디스 pub/sub 서버 서버 1번에서 관리되고 있다. 

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter02/Untitled%208.png" | relative_url }})

이런 해시테이블과 다르게 안정 해시는 해시 테이블 크기가 조정될 때 평균적으로 `Key/N(서버 수)`의 키만 재배치하도록 하는 해시 기술이다. 안정해시 외에도 상황에 맞는 해시함수를 사용하면 좋을 것 같음.

[안정 해시 (Consistent hashing)](https://velog.io/@dev-log/안정-해시-설계Consistent-hashing)

그림 2.10은 웹소켓 서버가 특정 사용자 채널에 위치 정보 변경 내역을 발행하는 과정이 어떻게 처리되는지 보여 준다.

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter02/Untitled%209.png" | relative_url }})

1. 웹소켓 서버는 해시 링을 참조하여 메시지를 발행할 레디스 pub/sub 서버를 선정한다.
2. 웹소켓 서버는 해당 서버가 관리하는 사용자 채널에 위치 정보 변경 내역을 발행한다.

### 친구 추가/삭제

새 친구를 추가하면 해당 클라이언트(앱)에 연결된 웹소켓 서버의 연결 핸들러에 그 사실을 알려야 한다. 새 친구의 pub/sub 채널을 구독할 수 있기 위해서이다.

앱에 콜백을 두고 친구가 추가되면 새 친구의 pub/sub 채널을 구독하라는 메시지를 보낸다.

친구가 삭제되도 동일하며 앱에서는 콜백호출 시 삭제된 친구의  pub/sub 채널을 구독 취소하라는 메시지를 웹소켓 서버로 보낸다.

### 친구가 많은 사용자

최대로 맺을 수 있는 친구의 수에 상한을 둔다(페이스북은 5000명이다). 수천 명의 친구를 구독하는 데 필요한 pub/sub  구독 관계는 클러스터 내의 많은 웹소켓 서버에 분산되어 있을 것이다. 친구들의 위치가 변경되는 데서 오는 부하는 각 웹소켓 서버가 나누어 처리할 것이다.

다만 그렇게 많은 친구를 둔 사용자의 채널이 존재하는 pub/sub 서버의 경우에는 조금 더  많은 부하를 감당하게 될 수 있다. 헤비 유저들의 채널도 모든 pub/sub 서버에 분산된다는 점을 감안하면 특정 서버에 막대한 부담을 줄 일은 없을 것이다.

### 주변의 임의 사용자

추가적인 기능으로 구현을 해볼 수 있을 것이다. 

지오해시에 따라 구축된 pub/sub 채널 풀을 두면 가능하다. 아래 표시된 지역은 네개의 지오해시 격자로 나눈 다음, 격자마다 채널을 하나씩 만들어 두면 된다.

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter02/Untitled%2010.png" | relative_url }})

해당 격자 내의 모든 사용자는 해당 격자에 할당된 채널을 구독한다. 격자 9q8znd의 경우를 예로 들어 살펴보자.

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter02/Untitled%2011.png" | relative_url }})

1. 사용자 2의 위치가 변경되면 웹소켓 연결 핸들러는 해당 사용자의 지오해시 ID를 계산한 다음, 해당 지오해시 ID를 담당하는 채널에 새 위치를 전송한다.
2. 근방에 있는 사용자 가운데 해당 채널을 구독하고 있는 사용자(사용자 2 제외)는 사용자 2의 위치가 변경되었다는 메시지를 수신한다.

격자 경계 부근에 있는 사용자를 잘 처리하기 위해서 모든 클라이언트는 사용자가 위치한 지오해시 뿐만 아니라 주변 지오해시 격자를 담당하는 채널도 구독한다.

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter02/Untitled%2012.png" | relative_url }})

끗!
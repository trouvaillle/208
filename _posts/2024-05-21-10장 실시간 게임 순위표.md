---
layout: post
title:  "10장 실시간 게임 순위표"
date:   2024-05-21 00:00:00 +0900
categories: study books system-design-interview-vol2
announced_on: 2024년 5월 21일
author: hyeonseop choi
---
# 실시간 게임 순위표

- 온라인 게임의 순위표 설계

## **1단계: 문제 이해 및 설계 범위 확정**

1. 시스템 규모 추정
    - 평균 일간 활성 사용자 수(DAU) 500만명, 월간 활성 사용자 수(MAU) 2500만명
2. 비지니스 추정
    - 게임에 참여한 모든 플레이어가 순위표에 포함됨.
    - 사용자는 경기에서 승리하면 1포인트를 얻음.
    - 각 선수는 하루 평균 10경기정도 플레이
    - 두 플레이어의 점수가 같을 경우 순위도 같음
    - 실시간 또는 준 실시간 순위표
    - 매달 새로운 토너먼트를 시작할 때마다 새로운 순위표 생성

### **기능 요구사항**

- 순위표에 상위 10명의 플레이어를 표시한다.
- 특정 사용자의 순위를 표시한다.
- 어떤 사용자보다 4순위 위와 아래에 있는 사용자를 표시한다. (보너스 문제)

### **비기능 요구사항**

- 점수 업데이트는 실시간으로 순위표에 반영한다.
- 일반적인 확장성, 가용성 및 안정성 요구사항

### **개략적 규모 추정**

- 게임을 하는 사용자가 24시간동안 고르게 분포한다고 가정하면 DAU가 500만명인 경우 초당 평균 50명의 사용자가 게임을 플레이하게됨. 하지만 실제로 균등할리가 없으므로 5배인 최대 250TPS로 추정
- 한 사용자가 하루 평균 10개의 게임을 플레이한다고 가정하므로 QPS는 50 * 10으로 500 QPS, 5배인 최대 2500QPS로 추정

## **2단계: 개략적 설계안 제시 및 동의 구하기**

### **API 설계**

`POST /v1/scores`

- 사용자가 게임에서 승리했을때 순위표에서 사용자의 순위를 갱신한다.

`GET /v1/scores`

- 순위표에서 상위 10명의 플레이어를 가져온다.

`GET /v1/scores/{:user_id}`

- 특정 사용자의 순위를 가져온다.

### **개략적 설계안**

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter10/Untitled.png" | relative_url }})

1. 사용자가 게임에서 승리하면 클라이언트는 게임 서비스에 요청을 보낸다.
2. 게임 서비스는 해당 승리가 정당하고 유효한 것인지 확인한 다음 순위표 서비스에 점수 갱신 요청을 보낸다.
3. 순위표 서비스는 순위표 저장소에 기록된 해당 사용자의 점수를 갱신한다.
4. 해당 사용자의 클라이언트는 순위표 서비스에 직접 요청하여 다음과 같은 데이터를 가져온다.
    1. 상위 10명의 순위표
    2. 해당 사용자의 순위

### **고려해볼만한 사항**

**클라이언트가 순위표 서비스와 직접 통신해야 하나?**

- 점수 갱신을 클라이언트에서 직접하는 경우 중간자 공격(man-in-the-middle attack)을 할 수 있기 때문에 보안상 안전하지 않다.
- 따라서 점수 갱신은 서버에서 설정되어야한다.

**게임 서비스와 순위표 서버 사이에 메시지 큐가 필요한가?**

- 게임 점수가 어떻게 사용되는지에 따라 크게 달라진다.
- 갱신되는 점수를 푸시알림, 분석 등등에 사용한다면 아래와 같이 카프카에 데이터를 넣는 것이 합리적일 수 있다.

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter10/Untitled%201.png" | relative_url }})

### **데이터 모델**

**관계형 데이터베이스**

- 규모 확장성이 그다지 중요하지 않고 사용자 수가 많지 않다면 RDB를 이용해볼만 하다. (비추라는 뜻)
- 사용자가 게임에서 승리한경우 1점을 추가하면 되므로 UPSERT 로 구현한다

```
# 레코드가 없으면
INSERT INTO leaderboard (user_id, score) VALUES ('mary1934', 1);

# 레코드가 있으면
UPDATE leaderboard set score = score + 1 where user_id='mary1934';
```

- 사용자의 순위를 가져오려면 순위표 테이블을 점수 기준으로 정렬한 다음 순위를 매기면 된다.

```
SELECT (@rownum := @rownum + 1) AS rank, user_id, score
FROM leaderboard
ORDER BY score DESC;
```

- 왜 비효율적인가?
    - 사용자의 순위를 파악하려면 모든 플레이어의 순위표를 정확한 위치에 정렬해야한다.
    - RDB는 지속적으로 변화하는 대량의 정보를 신속하게 처리하지 못한다.
    - 레코드의 수가 수백만개라면 정렬하는데만 수십초가 걸린다. 따라서 실시간성을 요구하는 애플리케이션에는 적합하지 않다.

**레디스**

- 수백만명의 사용자에 대해서도 예측 가능한 성능을 제공하고 복잡한 DB쿼리 없이도 일반적인 순위표 작업을 쉽게 수행하는 방법
- 레디스에서 제공해주는 `sorted set` 자료형을 사용하면 된다.

`sorted set 이란?` [http://redisgate.kr/redis/command/zsets.php](http://redisgate.kr/redis/command/zsets.php)

- `sorted set`은 집합과 유사한 자료형이다.
- `sorted set`은 내부적으로 해시테이블과 스킵리스트라는 두가지 자료 구조를 사용한다.
    - 해시 테이블은 사용자의 점수를 저장하기 위해서, 스킵 리스트는 특정 점수를 딴 사용자들의 목록을 저장하기 위해 쓰인다.

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter10/Untitled%202.png" | relative_url }})

`skip list` [http://redisgate.kr/redis/configuration/internal_skiplist.php](http://redisgate.kr/redis/configuration/internal_skiplist.php)

- 스킵리스트? => 빠른 검색을 가능하게 하는 자료형
- 단방향 연결 리스트에서 CRUD의 시간복잡도는 O(n) 이다
- 단방향 연결 리스트에 이진 검색 알고리즘처럼 중간 지점에 더 빨리 도달할 수 있도록 다단계 색인을 추가한 형태
    - 중간 노드를 하나씩 건너뛰는 1차 색인을 추가한다.
    - 1차 색인 노드를 하나씩 건너뛰는 2차 색인을 추가한다.
    - 노드 사이의 거리가 n-1 (n = 노드의 총 개수) 이 되면 색인을 추가하지 않는다.

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter10/Untitled%203.png" | relative_url }})

- 데이터의 양이 적을때는 스킵 리스트의 속도 개선 효과가 분명하지 않지만 데이터의 양이 많아질수록 효과가 분명하다.

`다시 sorted set`

- `sorted set`은 삽입이나 갱신 연산을 할 때 모든 원소가 올바른 위치에 자동으로 배치되며 새 원소를 추가하거나 기존 원소를 검색하는 시간 복잡도가 O(log(n))이므로 관계형 데이터베이스보다 쓰기, 조회 성능이 좋다.
- 레디스 정렬 집합을 사용할 구현
    - `ZADD`: 기존에 없던 사용자를 집합에 삽입한다. 기존 사용자의 경우에는 점수를 업데이트한다. 실행 소요시간은 O(log(n))이다.
    - `ZINCRBY`: 사용자 점수를 지정된 값만큼 증가시킨다. 집합에 없는 사용자의 점수는 0에서 시작한다고 가정한다. 실행 소요시간은 O(log(n))이다.
    - `ZRANGE`/`ZREVRANGE`: 점수에 따라 정렬된 사용자 중에 특정 범위에 드는 사용자들을 가져온다. 순서, 항목 수, 시작 위치를 지정할 수 있다. 실행 소요시간은 O(log(n) + m) 이다. (n = 정렬 집합의 크기, m = 가져올 항목 수)
    - `ZRANK`/`ZREVRANK`: 오름차순/내림차순 정렬하였을 때 특정 사용자의 위치를 가져온다. 실행 소요시간은 O(log(n)) 이다.

**정렬 집합을 사용할 경우 구현의 동작 원리**

1. 사용자가 점수를 획득한 경우
- 사용자가 경연에서 승리하면 `ZINCRBY`를 호출하여 순위표상의 사용자 점수를 1만큼 증가시킨다.

```
ZINCRBY leaderboard_feb_2021 1 'mary1934'
```

1. 사용자가 순위표 상위 10명을 조회하는 경우
- 가장 높은 점수를 받은 사용자부터 내림차순 정렬한 결과를 가져와야하므로 `ZREVRANGE`를 호출한다.
- 각 사용자의 현재 점수도 가져와야하므로 `WITHSCORES` 속성도 전달해야한다.

```
ZREVRANGE leaderboard_feb_2021 0 9 WITHSCORES
```

1. 사용자가 자기 순위를 조회하는 경우
- `ZREVRANK`를 호출하면 특정 사용자의 순위를 가져올 수 있다.

```
ZREVRANK leaderboard_feb_2021 'mary1934'
```

1. 특정 사용자 순위를 기준으로 일정 범위 내 사용자를 질의하는 경우
- `ZREVRANK`를 활용하면 특정한 사용자 전/후 순위의 사용자 목록을 얻어낼 수 있다.

```
# 사용자의 랭크가 361이라면 그 전/후 순위 플레이어 4명씩 가져오는 명령어
ZREVRANK leaderboard_feb_2021 357 365
```

**저장소 요구사항**

- 최소한 사용자 ID와 점수를 저장해야한다.
- 최악의 시나리오는 월간 활성 사용자 2500만명 모두가 최소 한 번 이상 게임에서 승리하는 바람에 모두 월 순위표에 올라와야하는 경우.
    - ID가 24자 문자열이고 점수가 16비트 정수라고 가정 한다면 순위표 항목당 26바이트가 필요하다.
    - 26 X 2500만 = 6억 5천만 바이트 => 650MB 의 저장공간이 필요하다.
    - 추가로 스킵리스트, 정렬 집합 해시의 사용량을 고려해 메모리 사용량을 두배로 늘린다고해도 최신 레디스 서버 한 대 만으로도 데이터를 충분히 저장할 수 있다.
- 추가로 고려해야할 요소 => CPU 및 I/O 사용량
    - 최대 QPS를 2500으로 계산했으므로 이 또한 단일 레디스서버로도 충분히 감당할 수 있는 부하임
- 장애는?
    - 레디스는 데이터를 디스크에 영속적으로 보관하는 옵션을 지원한다. 그러나 디스크에서 데이터를 읽어 대규모 레디스 인스턴스를 재시작하려면 시간이 많이 걸리므로 보통의 경우 레디스에 읽기 사본을 두는 식으로 구성한다.
    - 주 서버에 장애가 생기면 읽기 사본을 승격시켜 주 서버로 만들고 새로운 읽기 사본을 만들어 연결한다. (redis replication)

> redis replication http://redisgate.kr/redis/configuration/replication.php
> 

## **3단계: 상세 설계**

### **클라우드 서비스 사용 여부**

**자체 서비스를 이용하는 방안**

- 매월 정렬 집합을 생성하여 해당 기간의 순위표를 저장한다.
- 순위정보는 레디스에서, 사용자 세부 정보는 MySQL 에 저장해서 조회한다.

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter10/Untitled%204.png" | relative_url }})

**클라우드 서비스를 이용하는 방안(AWS)**

- AWS 람다 사용하기
    - 람다를 사용하면 서버를 직접 준비하거나 관리할 필요 없이 코드를 실행할 수 있다.
    - 람다는 필요할때만 실행되며 트래픽에 따라 그 규모가 자동으로 확장된다.
    - 구글은 Cloud Function, 애저는 Azure Function이라는 제품이 있다.
- 게임 서버는 AWS API 게이트웨이를 호출하고 이 게이트웨이는 적절한 람다 함수를 호출한다.
- 람다는 serverless 접근 방식이라 인프라 규모가 필요에 맞게 자동으로 확장되므로 관리포인트가 줄어드는 장점이 있다.

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter10/Untitled%205.png" | relative_url }})

### **레디스 규모 확장**

- 500만 DAU정도라면 한 대의 레디스 캐시 서버로도 충분히 지원할 수 있다.
- 하지만 원래 규모의 100배인 5억 DAU를 처리해야한다면?
    - 저장용량은 650MB -> 65GB로 증가하므로 샤딩 필요
    - 고정파티션 vs 해시파티션

**고정 파티션**

- 고정 파티션은 순위표에 등장하는 점수의 범위에 따라 파티션을 나누는 방안이다.
- 한달동안 획득할 수 있는 최대점수가 1000점이라면 아래와 같이 샤드를 10개씩 둬서 분리할 수 있다.

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter10/Untitled%206.png" | relative_url }})

- 이 기능이 제대로 작동하려면 순위표 전반에 점수가 고르게 분포되어야한다. 만약 그렇지 않다면 샤드에 할당되는 점수 범위를 조정하여 비교적 고른 분포가 되도록 해야 한다.
- 애플리케이션이 샤딩 처리의 주체가 된다고 가정하면?
    - 특정 사용자의 점수를 입력하거나 갱신할때는 해당 사용자가 어느 샤드에 있어야하는지 알아야한다.
    - 사용자의 점수를 MySQL에 저장해서 샤드 위치를 알아내거나 사용자 ID와 점수 사이의 관계를 저장하는 2차캐시를 통해 샤드 위치를 알아낼 수 있다.
- 순위표에서 상위 10명의 플레이어를 가져오려면, 가장 높은 점수가 저장되는 샤드에서 상위 10명을 가져오면 된다.

**해시 파티션**

- 레디스 클러스터는 여러 노드에 데이터를 자동으로 샤딩하는 방법을 제공한다 (해시 파티션)
- 사용자들의 점수가 특정 대역에 과도하게 모여 있는 경우에 효과적
- 각각의 키가 특정한 해시 슬롯에 속하도록 하는 샤딩 기법
    - 총 16384개 해시 슬롯이 있고 CRC16(key) % 16384의 연산을 수행하며 어떤 키가 어느 슬롯에 속하는지 계산한다.
    - 3개 노드로 구성된 레디스 클러스터의 사례
        - 첫번째 노드에는 해시슬로 [0, 5500]이 있다.
        - 두번째 노드에는 해시슬롯 [5501, 11000]이 있다.
        - 세번째 노드에는 해시슬롯 [11001, 16383]이 있다.

> 왜 16384야?
> 
> 1. **CRC16 해시 함수**:
>     - Redis 클러스터는 키를 해싱하기 위해 CRC16(Cyclic Redundancy Check 16-bit) 해시 함수를 사용합니다. CRC16은 16비트 값을 반환하며, 이는 0부터 65535까지의 값을 가질 수 있습니다.
> 2. **슬롯 개수 결정**:
>     - 65536개의 슬롯을 사용하는 대신, Redis는 이를 16384개의 슬롯으로 나누어 사용합니다. 이는 각 슬롯에 대해 더 많은 키가 분포될 수 있도록 하여 슬롯 분포의 균형을 맞추고, 관리의 복잡성을 줄이기 위한 것입니다.
> 3. **2의 제곱수**:
>     - 16384는 2의 제곱수(2^14)입니다. 컴퓨터 시스템에서 2의 제곱수는 이진수로 처리하기 쉽고, 연산 효율성이 높습니다. 이를 통해 해시 값을 슬롯에 매핑하는 과정이 단순해지고 효율적입니다.
- 따라서 모든 키를 재분배하지 않아도 클러스터에 쉽게 노드를 추가하거나 제거할 수 있다.

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter10/Untitled%207.png" | relative_url }})

- 점수를 갱신하려면 해당 사용자의 샤드를 찾아 거기서 해당 사용자 점수를 변경하기만 하면 된다.
- 상위 10명의 플레이어를 검색해야하는 경우 분산-수집 접근법을 사용해야한다
    - 상위 k개의 결과를 반환해야 하는 경우 각 샤드에서 많은 데이터를 읽고 또 정렬해야 하므로 지연 시간이 늘어난다
    - 가장 느린 파티션에서 데이터를 다 읽고 나서야 질의 결과를 계산할 수 있으므로 지연 시간이 길어진다.
    - 특정 사용자의 순위를 결정할 간단한 방법이 없다.
- **따라서 순위표 요구사항은 해시파티션보다 고정파티션이 더 유리하다.**

**레디스 노드 크기 조정**

- 쓰기 작업이 많은 애플리케이션에는 많은 메모리가 필요하다.
    - 장애에 대비해 스냅숏을 생성할 때 필요한 모든 쓰기 연산을 감당할 수 있어야 함
    - 쓰기 연산이 많은 애플리케이션에는 메모리를 두 배 더 할당하는 것이 안전한다.
- 레디스는 성능 벤치마킹을 위해 redis-benchmark라는 도구를 제공한다.
    - 여러 클라이언트가 동시에 여러 질의를 실행하는 것을 시뮬레이션하여 주어진 하드웨어로 초당 얼마나 많은 요청을 처리할 수 있는지 측정한다.

> redis benchmark: http://redisgate.kr/redis/server/redis-benchmark.php
> 

### **대안: NoSQL**

- 왜 갑자기 NoSQL?
    - 쓰기 연산에 최적화되어 있다.
    - 같은 파티션 내의 항목을 점수에 따라 효율적으로 정렬 가능하다.
- 후보 NoSQL
    - 아마존의 DynamoDB
    - 카산드라
    - MongoDB

**Redis 말고** DynamoDB**를 사용해보자**

- DynamoDB 장점
    - 기본키 이외의 속성을 활용하여 데이터를 효과적으로 질의할 수 있도록 전역 보조 색인을 제공한다.
    - 전역 보조 색인은 부모테이블의 속성들로 구성되지만 기본 키는 부모 테이블과는 다르다.
    - 전역 보조 색인을 사용하면 기본 테이블의 파티션 키 외에도 다른 속성을 기준으로 효율적인 조회가 필요할 때 유용

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter10/Untitled%208.png" | relative_url }})

> 일반 사용자 테이블
> 

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter10/Untitled%209.png" | relative_url }})

> 전역 보조 색인을 적용한 테이블
> 

- 고민포인트1: 부하가 높아지면?
    - 가장 최근 한달치 데이터가 동일한 파티션에 저장되면 해당 파티션이 핫 파티션이 된다.
    - 이 문제를 해결하는 방법은 데이터를 n개 파티션으로 분할하고 파티션 번호를 파티션 키에 추가하는 방법 (쓰기 샤딩 패턴)
    - 읽기 및 쓰기를 모두 복잡하게 하므로 장단점을 꼼꼼히 따져봐야함

![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter10/Untitled%2010.png" | relative_url }})

> 파티션 키: game_name#{year-month}#p{partition_number}
> 
- 고민포인트2: 상위 10개 결과를 가져오려면?
    - 파티션이 3개라고 가정했을때 3개의 파티션에 상위 10개, 총 30개의 로우를 조회하고 30개중에서 다시 정렬해서 상위 10개의 결과를 리턴 (분산-수집)
- 고민포인트3: 그래서 얼마나 많은 파티션을 둬야하는데?
    - 쓰기 볼륨 또는 DAU를 기준으로 결정할 수 있다.
    - 같은 달 데이터를 여러 파티션에 고르게 분산시키면 한 파티션이 받는 부하는 낮아지지만 최종 순위표를 만들기 위해 읽어야 하는 파티션은 더 많으므로 복잡성이 증가한다.
    - 따라서 파티션 수는 신중한 벤치마킹으로 결정해야한다.
    - 신중한 벤치마킹으로 파티션수를 적절하게 구했어도 결국 사용자의 상대적 순위를 쉽게 구해올 수 없다.
- 결론 => 레디스를 써야되는 프로그램에 NoSQL을 쓰지 말자.

## **4단계: 마무리**

- 이번 장에서 알아본 내용
    - 시스템 규모 측정
    - 요구사항 분석
    - RDB를 활용해서 순위표 만들기 (비추)
    - 레디스를 사용해서 순위표 만들기 (추천)
    - NoSQL 사용해서 순위표 만들기 (비추)

### **추가로 고려해볼만한 사항**

**더 빠른 조회**

- 순위표에 표시할 사용자 ID와 사용자 객체 사이의 대응 관계를 저장한다. 이렇게하면 따로 데이터베이스에 질의하지 않아도 빠르게 사용자 정보를 확인할 수 있다. (사용자 정보까지 레디스에 저장한다는 의미인듯?)

**동점자 순위 판정**

- 두 사용자의 점수가 같은 경우 누가 먼저 점수를 받았는지에 따라 순위를 매길 수 있다.
- 해당 사용자가 마지막으로 승리한 경기의 타임스탬프 사이의 대응관계를 저장하면 동점자 순위도 매길 수 있다.

**시스템 장애 복구**

- 레디스 클러스터에도 대규모 장애는 발생할 수 있다.
- 사용자가 게임에서 승리할때마다 MySQL 데이터베이스에 append 형태의 로그로 쌓아두면 장애 발생시 사용자별로 모든 레코드를 훑으면서 ZINCRBY를 호출하면 오프라인에서 순위표를 복구할 수 있다.
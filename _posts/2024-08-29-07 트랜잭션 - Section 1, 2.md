---
layout: post
title:  "07. 트랜잭션 - Section 1, 2"
date:   2024-08-29 12:00:00 +0900
categories: study books data-intensive-applications
author: 윤현준
announced_on: 2024년 8월 29일
---
### 현실 세계의 문제

DB 소프트웨어, 하드웨어가 죽거나 실패할 수 있다.

App도 죽을 수있다.

App - DB 네트워크가 끊기거나 DB 노드 간 네트워크가 끊길 수 있다.

여러 클라가 동시에 DB 에 쓰기를 실행해서 다른 클라의 쓰기를 덮어쓸 수 있다.

등등..

### **트랜잭션 등장**

복잡한 문제를 단순화하기 위한 메커니즘이 필요했는데.. **트랜잭션**이 채택되었다.

트랜잭션은 데이터베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화 하려는 목적으로 만들어졌다. 

DB 에서 오류 시나리오와 동시성 문제를 보장해주면(안전성 보장) 애플리케이션을 설계할 수 있었다.

### 시대 별 트랜잭션

관계형 DB 의 트랜잭션은 1975년에 소개한 첫번째 SQL 데이터베이스 IBM 시스템 R 의 구현을 따른다. 우리가 익히 알고있는 트랜잭션의 개념을 말한다.

2000년대 후반 고가용성의 필요성이 주목받으며 복제와 파티셔닝 기능을 탑제한 비관계형(NoSQL) DB 의 인기가 높아졌다. 새로운 세대의 DB 는 비용을 고려하여 트랜잭션을 완전히 포기하거나 과거보다 훨씬 약한 보장을 제공하며 트랜잭션의 의미를 약화시켰다. 

관점에 따라 이점과 한계를 이해하고 트랜잭션의 개념을 살펴봐야 한다.

### ACID(or BASE)

트랜잭션은 ACID 를 제공해 안전성을 보장한다고 흔히 알려져있다.

현실의 DB 는 각 기능의 구현이 제각각이며 특히 격리성의 의미는 모호함이 많다. 

ACID 의 표준을 따르지 않는 시스템을 BASE 라고 부르는데 더 모호하다. 

**원자성**

동시성과 관련이 없으며 몇 개의 쓰기 작업으로 이루어진 트랜잭션에서 ALL or NOTHING 을 만족하는 것을 말한다.

**일관성**

복제 시스템의 일관성, 파티셔닝의 일관성, CAP 정리에서 일관성도 있지만 ACID 는 DB 가 항상 “좋은상태” 에 있어야 함을 의미한다.

데이터의 불변식을 항상 만족해야 한다.

- 통장 잔액이 0원을 넘어야 하는 제약 조건이 있는 경우
- 800 을 가진 A 가 1000원을 B 에게 계좌이체 했다.
- 잔액이 -200 원으로 입력되며 제약 조건에 걸렸고 연산은 롤백되었다.

일관성을 달성하려면 DB 보다 애플리케이션에서 더 신경써야 한다.

**격리성**

서로 다른 트랜잭션은 격리되어야 하고, 방해하면 안된다. DB 는 순차적으로 실행됨을 보장해야 한다.

<img src="{{ "/assets/img/study/books/data-intensive-applications/chapter07/section1-2/image.png" | relative_url }}" width="720px"/>

**지속성**

트랜잭션이 성공적으로 커밋됐다면 어떤 문제에도 기록된 데이터는 보장되어야 한다. 

데이터 기록에 대한 의미가 시대 별로 변했다. **비휘발성 저장소 기록** → **디스크 or SSD → 복제** 

복제와 관련해서 절대적 보장을 제공하는 한 가지 기법은 없으며 여러 기법을 통해 최대한의 보장을 제공하려고 한다.

### 다중 객체 트랜잭션

한 트랜잭션에서 여러 객체를 변경할 때 원자성과 격리성을 고려해야 한다.

**이메일과 읽지 않은 메시지 개수를 별개의 필드에 저장하는 경우** 

<img src="{{ "/assets/img/study/books/data-intensive-applications/chapter07/section1-2/image%201.png" | relative_url }}" width="720px"/>

트랜잭션 중간에 새로운 조회 트랜잭션이 발생하면 읽지 않은 메시지 수와, 읽지 않은 메시지 개수는 다를 수 있다.

<img src="{{ "/assets/img/study/books/data-intensive-applications/chapter07/section1-2/image%202.png" | relative_url }}" width="720px"/>

트랜잭션 실행 도중 오류가 발생해도 위와 같은 상황이 발생할 수 있다. 

많은 분산 데이터스토어는 여러 파티션에 걸쳐 구현이 어렵고 가용성과 성능이 방해되어 다중 객체 트랜잭션 지원을 포기했다. 단일 객체로 삽입, 갱신, 삭제로 충분히 사용 가능하지만 원자성이 없으면 오류 처리가 복잡해지고 격리성이 없으면 동시성 문제가 발생 가능하다. 애플리케이션 개발자는 그에 따른 고려가 필요하다.

### 단일 객체 트랜잭션

단일 객체도 동일하다.

**20KB 의 JSON 문서를 DB 에 쓸 때**

- (원자성) 첫 10KB 를 보낸 후 네트워트 연결이 끊기면?
- (격리성) 문서를 쓰고 있을 때 다른 클라이언트에서 그 문서를 읽으면?

### 오류와 어보트 처리

트랜잭션의 핵심은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 점이다.

하지만 모든 시스템이 이 철학을 따르지 않는데, 레일스의 액티브 레코드나 장고 같은 인기 있는 ORM 은 어보트 된 트랜잭션을 재시도하지 않는다.

롤백은 효과적이지만 트랜잭션을 재시도하는 것에 주의해야 할 점 이 있다. 

- 트랜잭션이 실제로 성공했지만 클라이언트가 커밋 성공을 알리는 도중에 네트워크가 끊기면 재시도 시 두번 실행된다.
- 오류가 영구적이면 재시도해도 소용 없다.

### 완화된 격리 수준

데이터의 동시성 문제는 타이밍에 운이 없을 때 나타나므로 발견하기도 재현하기도 어렵다. 

그 이유로 DB 는 직렬으로 실행하여 트랜잭션 격리를 제공하고 동시성 문제를 감추려 하지만 비용이라는 현실적인가 있어 완화된 격리 수준을 많이 사용한다. 

완화된 트랜잭션 격리가 유발하는 동시성 버그는 실제로 큰 장애로 연결되기 때문에 문제를 잘 이해하고 방지하는 방법을 알아야 한다.

https://bitcointalk.org/index.php?topic=499580

[https://www.reddit.com/r/Bitcoin/comments/1wtbiu/how_i_stole_roughly_100_btc_from_an_exchange_and/?rdt=36379](https://www.reddit.com/r/Bitcoin/comments/1wtbiu/how_i_stole_roughly_100_btc_from_an_exchange_and/?rdt=36379) 

격리 수준 표

<img src="{{ "/assets/img/study/books/data-intensive-applications/chapter07/section1-2/image%203.png" | relative_url }}" width="720px"/>

### 커밋 후 읽기 - read committed

**더티 읽기 방지 보장**

<img src="{{ "/assets/img/study/books/data-intensive-applications/chapter07/section1-2/image%204.png" | relative_url }}" width="720px"/>

- 이전 예제에서 사용자는 읽지 않은 새 이메일을 볼 수 있지만 갱신된 개수는 볼 수 없다.
- 트랜잭션이 나중에 롤백될 데이터, 실제로 커밋되지 않은 데이터를 볼 수 있다.

**더티 쓰기 방지 보장**

동시에 서로 다른 트랜잭션에서 같은 데이터를 덮어 쓰는 것을 막아야 한다.

<img src="{{ "/assets/img/study/books/data-intensive-applications/chapter07/section1-2/image%205.png" | relative_url }}" width="720px"/>

- 중고차 판매 웹 사이트에서 앨리스와 밥이 동시에 차를 사려면 두 번의 쓰기가 필요하다
- 1. 목록이 구매자를 반영하고 2. 판매 송장이 구매자에게 전송돼야 한다.
- 위의 경우 중고차는 밥에게 판매됐지만, 송장은 앨리스에게 전송되었다.

**구현**

가장 흔한 방법은 로우 수준 잠금을 사용해 제어하는 것이다. 하지만 더티 읽기의 경우 쓰기 잠금 지연에 종속되어 응답시간이 늦어질 수 있다. 그런 이유로 DB 는 과거의 값과 새로쓴 값을 기억하여 필요에 따라 값을 제공한다.

### 스냅숏 격리와 반복 읽기 (repeatable read)

커밋 후 읽기도 구멍이 있다.

같은 값을 제어하는 다른 트랜잭션의 커밋 이전, 이후에 조회한 값이 다르다는 것이다. (nonrepeatable read, read skew)

<img src="{{ "/assets/img/study/books/data-intensive-applications/chapter07/section1-2/image%206.png" | relative_url }}" width="720px"/>

- 앨리스는 1, 2 계좌에 500원 씩 총 1000원을 저금했다.
- 1계좌에서 2계좌로 100원을 전송하는 트랜잭션을 실행하려고 한다.
- 트랜잭션이 처리되는 순간 계좌 잔고를 조회하면 1계좌 500원, 2계좌 400원 총 900원을 보게 된다.
- 조회 트랜잭션이 끝난 시점에 다시 조회하면 정상적으로 보인다.

이런 경우 지속적인 문제는 아니지만, **백업**이나 **통계 분석 질의**를 하는 경우 일관성이 깨질 수 있다.

**스냅숏 격리 구현**

DB 는 객체마다 커밋된 버전 여러 개를 유지하여 진행 중인 여러 트랜잭션에서 서로 다른 시점의 DB 상태를 볼 수 있다. (MVCC 다중 버전 동시성 제어) 

갱신은 내부에서 삭제와 생성으로 변환해 로우를 삽입한다. 

DB 는 삭제 필드를 보고 사용하지 않는 경우 가비지 컬렉션을 운영한다.

<img src="{{ "/assets/img/study/books/data-intensive-applications/chapter07/section1-2/image%207.png" | relative_url }}" width="720px"/>

트랜잭션에서 데이터를 조회할 때 일관된 스냅숏을 보기 위해 규칙을 정했다.

1. DB 는 트랜잭션을 시작할 때 그 시점에 진행 중인 모든 트랜잭션의 목록을 만든다. 이 트랜잭션들이 쓴 데이터는 모두 무시된다. 
2. 어보트된 트랜잭션이 쓴 데이터는 모두 무시된다.
3. 트랜잭션 ID 가 더 큰 트랜잭션이 쓴 데이터는 그 트랜잭션의 커밋 여부에 관계 없이 모두 무시된다.
4. 그 밖의 모든 데이터는 애플리케이션의 질의로 볼 수 없다.

**색인과 스냅숏 격리**

단순한 방법은 색인이 객체의 모든 버전을 가리키게 하고 필터링하는 것이다.

몇몇 DB 는 구현 세부 사항이 다른데, 최적화를 위해 덮어 쓰지 않고 색인 트리를 복사해서 유지하기도 한다.

**끝.**

반복 읽기라는 이름은 구현이 독립적이지 않다(DB 벤더의 구현이 다르다). 그 이유가 스냅숏 격리의 개념이 나오기 이전에 SQL 표준에 정의되서 라고 한다.
---
layout: post
title:  "06. 파티셔닝 - Section 3, 4"
date:   2024-08-15 17:30:00 +0900
categories: study books data-intensive-applications
author: 한재민
announced_on: 2024년 8월 22일
---
# 파티션 재균형화

클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정

- 질의 처리량이 증가해서 늘어난 부하를 처리하기 위해 CPU를 더 추가하고 싶을 때
- 데이터셋의 크기가 증가해서 데이터셋 저장에 사용할 디스크와 램을 추가하고 싶을 때
- 장비에 장애가 발생해서 그 장비가 담당하던 역할을 다른 장비가 넘겨받아야 할 때

### 일반적인 최소 요구사항

- 재균형화 후, 부하의 균등 분배
- 재균형화 도중에 읽기/쓰기 요청 처리
- 네트워크와 디스크 I/O 부하를 최소화

즉, 재균형화로 발생하는 모든 상황을 최적화하길 원한다는 것. (*이상적인 것?!*)

# 재균형화 전략

### 해시 값에 Mod N 연산?

노드 개수 N이 바뀌면 대부분의 키가 변경됨 → 재균형화 비용이 지나치게 커짐

### 파티션 개수 고정

매우 간단한 해결책으로 파티션을 노드 대수보다 많이 만드는 것

<img src="{{ "/assets/img/study/books/data-intensive-applications/chapter06/section3-4/image.png" | relative_url }}" width="720px"/>

1. 파티션을 크게 만들어, 각 노드에 파티션 할당
2. 새노드가 추가된다면, 기존 노드의 파티션을 가져옴

<aside>
💡 장점 vs 단점
- 장점: 키의 변경이 없고, 파티션 통째로 이동하면 됨
- 단점: 파티션 이동은 시간이 오래 걸릴 수 있음 
(진행 중인 동안에는 기존에 할당된 파티션을 사용하면 됨)

</aside>

- 리악, 엘라스틱서치, 카우치베이스, 볼드모드에서 사용되는 방식

그러나 일반적으로 파티션 분할을 지원하지 않는 경우가 많기 때문에 트레이드오프를 고려해서 적당한(?) 파티션 크기를 정해야 함. 

너무 크면 재균형화 혹은 노드 장애로부터 복구할 때 비용(시간)이 크고, 그렇다고 작게하면 재균형화가 많이 발생 (항상 그렇듯 상황에 맞게…)

### 동적 파티셔닝

파티션 경계를 수동으로 재설정하는 것은 매우 성가신 일! 그렇기에 파티션을 동적으로! 

<aside>
💡 파티션 크기가 설정된 값을 넘어서면 두 개로 쪼개고, 데이터가 많이 삭제되어 임계값 아래로 떨어지면 파티션을 합체

</aside>

이 때문에 HBase나 리싱크DB는 키 범위 파티셔닝을 동적으로 함.

파티션 개수가 전체 데이터 용량에 맞춰 조정된다는 이점을 가지고 있지만, 최초 빈 데이터베이스의 경우는 파티션 경계를 어떻게 정해야하는지 사전 정보가 없음.

- HBase나 몽고DB는 초기 파티션 집합을 설정 할 수 있도록 함. 즉, 사전 분할(pre-splitting)

### 노드 비례 파티셔닝

노드당 할당되는 파티션 개수를 고정

- 노드 대수가 변함이 없으면, 데이터셋 크기에 비례하여 파티션의 크기가 커짐
- 노드 대수를 늘리면, 파티션의 크기가 작아짐

일반적으로 위의 방법을 사용하면 파티션의 크기가 안정적으로 유지됨

<aside>
💡 새 노드가 클러스터에 추가되면 파티션을 무작위로 선택해 분할하여 새 노드에 할당
(여러 파티션에 대해 평균적으로 보면 균등함)

</aside>

참고로 파티션 경계를 무작위로 선택하려면 해시 기반 파티셔닝을 사용해야 하는데, 해당 방식은 일관성 해싱의 정의와 가깝게 대응함

### 운영: 자동 재균형화와 수동 재균형화

완전 자동 재균형화는 유지보수에 편할지언정 예측하기는 어려움

**관련 예시**

1. 특정 노드에 과부하가 걸려 일시적으로 요청 처리가 늦어짐
2. 다른 노드들은 해당 노드가 죽었다고 판단
3. 부하를 나누기 위해 자동으로 클러스터 재균형화

결과적으로 모든 노드에 부하가 발생하기 때문에 오히려 연쇄 장애로 이어질 수 있음

그래서?! 완전 자동보다는 느리지만 사람이 개입하는 편이 좋을 수 있음!

# 요청 라우팅

파티션이 재균형화되면 노드에 할당되는 파티션이 바뀌는데 클라이언트 요청은 어떻게 해야만 할까?

일명 서비스 찾기(service discovery)

<img src="{{ "/assets/img/study/books/data-intensive-applications/chapter06/section3-4/image%201.png" | relative_url }}" width="720px"/>

1. 클라이언트가 아무 노드에 접속, 파티션이 다르다면 다른 노드로 전달
2. 클라이언트의 모든 요청을 라우팅 계층으로 전달
3. 클라이언트가 모든 정보를 알고 있음 (직접 접근)

하지만 가장 주요한 문제는 노드에 할당된 파티션의 변경 사항을 어떻게 알 수 있는가 하는 부분.

- 모든 곳에서 정보가 일치해야 하기 때문
- 분산 시스템에서 합의를 이루는 데 쓰이는 프로토콜은 구현하기가 까다로움

가장 간단하게 많은 분산 데이터 시스템은 코디네이션 서비스인 주키퍼를 사용.

<img src="{{ "/assets/img/study/books/data-intensive-applications/chapter06/section3-4/image%202.png" | relative_url }}" width="720px"/>

> HBase, 카프카 등은 파티션 할당을 추적하는데 주키퍼 사용, 몽고DB는 자체적인 config server를 사용하고 mongos를 라우팅 계층으로 사용
>
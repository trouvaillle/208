---
layout: post
title:  "09. 일관성과 합의 - Section 3, 4"
date:   2024-10-09 22:00:00 +0900
categories: study books data-intensive-applications
author: 유석모
announced_on: 2024년 10월 10일
---
## 순서화 보장 <small class="weak">Ordering Guarantees</small>
<aside mark="💡">
<strong>순서화</strong>란 여러 요소가 있을 때 선후 관계를 결정하는 것이다.
</aside>

선형성 레지스터는 한 부의 데이터만 존재하는 것처럼 행동하고 이는 한 순간에 하나의 동작만 원자적으로 수행되는 것처럼 보인다. 이는 연산들이 정해진 순서대로 동작하는 것을 의미한다.

- 5장의 단일 리더 복제에서 리더의 주 목적은 **쓰기의 순서**를 결정하여 쓰기 충돌을 방지하는 것이다.
- 7장의 직렬성은 트랜잭션들이 **일련 순서**에 따라 실행되는 것처럼 보장하는 것이다.
- 9장의 분산 시스템에서 **타임스탬프**를 사용하는 것은 순서화로 볼 수 있다.

순서화, 선형성, 합의 사이에는 깊은 연결 관계가 있다.

<br/>

### 순서화와 인과성 <small class="weak">Ordering and Causality</small>

순서화는 **인과성**을 보존하는데 도움을 준다.

- 167쪽 "일관된 순서로 읽기"에서 질문보다 응답을 먼저 보는 경우 인과를 위반한다. 질문과 답변 사이에 **인과적 의존성(causal dependency)**가 있다고 한다.
- 5장에서 네트워크 지연으로 인해 존재하지 않는 로우를 갱신하는 경우 인과를 위반한다. 여기서 인과성은 로우가 갱신되기 전에 먼저 생성돼야 함이다.
- 186쪽 "동시 쓰기 감지"에서 두 개의 연산 A와 B가 있을 때 둘 중 하나가 먼저 실행되면 **이전 발생(happened before)** 관계가 있음을 알 수 있다. A가 B보다 먼저 실행됐다면 B는 A에 인과적 연결을 가질 수 있다.
- 236쪽 "스냅숏 격리와 반복 읽기"에서 트랙잭션은 일관된 스냅숏으로부터 읽는다고 했다. 이는 **인과성에 일관적(consistent with casuality)**라는 의미다.
- 246쪽 "쓰기 스큐와 팬텀"에서 쓰기 스큐는 트랜잭션 사이의 인과적 의존성을 추적함으로써 검출한다.
- 9장의 축구를 보는 예제에서 앨리스가 결과를 외치고 밥이 뒤처진 결과를 보는 것은 인과성 위반이다.

<aside mark="💡">
<strong>인과성</strong>은 이벤트에 순서를 부과한다.<br/>
무엇이 무엇보다 먼저 일어났는가를 정의한다.
</aside>


시스템이 인과성에 의해 부과된 순서를 지키면 **인과적으로 일관적(causally consistent)**이라고 한다. 스냅숏 격리는 인과적 일과성을 제공한다.

<br/>

#### 인과적 순서가 전체 순서는 아니다

**전체 순서(total order)**는 항상 두 요소의 크고 작은 관계를 결정할 수 있다.

<dl>
    <dt>선형성</dt>
    <dd>선형성 시스템에서는 연산의 <strong>전체 순서</strong>를 정할 수 있다.<br/>타임라인이 하나다.</dd>
    <dt>인과성</dt>
    <dd>두 연산이 동시적이면 순서를 비교할 수 없다.<br/>타임라인이 1개 이상이다.</dd>
</dl>

<img src="{{ "../assets/img/study/books/data-intensive-applications/chapter09/section3-4/git-branch.png" | relative_url }}" alt="image" style="background: white; padding: 1rem;"/>

인과적 의존성 그래프는 깃의 버전 히스토리와 유사하다.<br/>
서로 다른 브랜치의 순서는 정할 수 없지만 동일 브랜치의 부분 순서는 정의할 수 있다.

<br/>

#### 선형성은 인과적 일관성보다 강하다

선형성은 인과성을 **내포한다**. 즉, 선형적이면 인과적이다.<br/>
333쪽 "선형성의 비용"과 같이 선형성은 네트워크 지연이 크면 성능과 가용성에 해가 될 수 있다.

선형성은 인과성을 보존하는 유일한 방법이 아니다.<br/>
인과적 일관성은 선형성보다 효율적으로 구현될 수 있다.

<aside mark="💡">
선형성이 필요한 것처럼 보이는 다수의 시스템에 진짜로 필요한 것은 <strong>인과적 일관성</strong>이다.<br/>
</aside>

<br/>

#### 인과적 의존성 담기
인과성을 유지하기 위해 어떤 연산이 다른 연산보다 **먼저 실행됐는지** 알아야 한다.<br/>
대표적인 기법은 186쪽 "동시 쓰기 감지"처럼 **버전 벡터**를 활용하는 것이다.<br/>
단일 키뿐만 아니라 전체 데이터베이스에 걸친 의존성을 추적해야 하므로 버전 벡터를 일반화해야한다.

260쪽 "직렬성 스냅숏 격리(SSI)"에서 충돌 검출에서도 비슷한 아이디어가 나타난다.<br/>
트랜잭션이 커밋을 원할 때 데이터베이스는 읽은 데이터의 버전이 여전히 최신인지 확인한다.

<br/>

### 일련번호 순서화 <small class="weak">Sequence Number Ordering</small>

**일련번호**나 **타임스탬프**를 써서 이벤트의 순서를 정할 수 있다.<br/>
타임스탬프는 일 기준 시계대신 **논리적 시계**에서 얻어도 된다.<br/>
논리적 시계는 일련번호를 생성하는 알고리즘이고 보통 카운터를 사용한다.

일련번호나 타임스탬프는 크기가 작고 **전체 순서**를 제공한다.<br/>
항상 두 개의 일련번호를 비교해서 선후 관계를 결정할 수 있다.<br/>
특히 **인과성에 일관적인** 전체 순서대로 일련번호를 생성할 수 있다.

인과성에 일과적이지 않은 전체 순서의 예시는 UUID 부여로 인과에 대한 아무 의미도 없다.

<br/>

#### 비인과적 일련번호 생성기

단일 리더가 없는 경우 아래와 같은 방법을 통해 일련번호를 생성할 수 있다.
하지만 **인과성에 일관적이지 않다**.

<dl>
    <dt>노드 별 독립적인 일련번호 생성</dt>
    <dd>두 노드가 있다면 하나는 홀수, 하나는 짝수 일련번호를 생성한다.<br/>일련번호의 이진 표현에서 앞의 몇 비트를 예약하면 서로 다른 노드에서 일련번호의 유일성이 보장된다.<br/>⚠️ 각 노드의 초당 연산수가 달라 다른 노드 간의 선후 연산을 알 수 없다.</dd>
    <dt>물리적 시계에서 얻은 타임스탬프</dt>
    <dd>해상도가 충분히 높다면 전체 순서를 정할 수도 있다.<br/><span title="291쪽 &quot;이벤트 순서화용 타임스탬프&quot; 참고">최종 쓰기 승리 충돌 해소 방법에서도 사용된다.</span><br/>⚠️ 물리적 시계는 시계 스큐에 종속적이어서 인과성에 일관적이지 않게 될 수 있다. 그림 8-3이 그 사례다.</dd>
    <dt>블록 할당자</dt>
    <dd>노드 A는 1~1,000, 노드 B는 1,000~2,000까지의 블록을 차지한다.<br/>각 노드는 독립적으로 자신의 블록에서 일련번호를 배정한다.<br/>⚠️ 1001 연산이 1 연산보다 먼저 발생했을 수 있다.</dd>
</dl>

<br/>

#### 램포트 타임스탬프 <small class="weak">Lamport Timestamp</small>

램포트 타임스탬프(Lamport timestamp)는 **인과성에 일관적인** 일련번호를 생성하는 간단한 방법이다.<br/>
램포트 타임스탬프는 **(카운터, 노드 ID)**의 쌍이다.

램포트 타임스탬프는 전체 순서화를 제공한다.<br/>
카운터가 큰 것이 타임스탬프가 크고, 카운터 값이 같으면 노드 ID가 큰 것이 타임스탬프가 크다.

모든 노드와 클라이언트가 지금까지 본 카운터 값 중 **최댓값**을 추적하고 모든 요청에 그 최댓값을 포함시키는 것이 인과성에 일관적으로 만들어주는 핵심 아이디어다.<br/>
노드가 자신의 카운터 값보다 큰 최대 카운터를 가진 요청이나 응답을 받으면 그 최댓값으로 카운터를 증가시킨다.

186쪽 "동시 쓰기 감지"에서 봤던 버전 벡터와 혼동된다.<br/>
버전 벡터는 두 연산이 동시적인지 또는 인과적으로 의존하는알 수 있다.<br/>
램포트 타임스탬프의 전체 순서화로부터 두 연산이 동시적인지 또는 인과적으로 의존성이 있는지는 알 수 없다.

<img src="{{ "../assets/img/study/books/data-intensive-applications/chapter09/section3-4/lamport-timestamp.png" | relative_url }}" alt="image" width="700px" />

<br/>

#### 타임스탬프 순서화로는 충분하지 않다
사용자명에 대한 유일성 제약 조건 같은 것을 구현하면 연산의 전체 순서가 있는 것으로는 충분하지 않다.<br/>
사후에 성공하는 쪽은 결정할 수는 있지만 **당장** 결정해야할 때는 전체 순서로 부족하다.<br/>
언제 전체 순서가 확정되는지 알아야한다.<br/>
이는 **전체 순서 브로드캐스트**의 주제로 이어진다.

<br/>

### 전체 순서 브로드캐스트 <small class="weak">Total Order Broadcast</small>
단일 CPU 코어 또는 단일 리더는 연산의 전체 순서를 정하기 쉽다.<br/>
처리량이 단일 리더의 허용량을 초과할 경우 시스템을 확장하거나 장애 시 복구를 어떻게 처리할 것인가가 어려운 문제다.<br/>
이는 **전체 순서 브로드캐스트(total order broadcast)**나 **원자적 브로드캐스트(atomic broadcast)**로 알려져 있다.

전체 순서 브로드캐스트는 보통 노드 사이에 메시지를 교환하는 프로토콜로 기술된다.<br/>
비공식적으로 두 가지 안전성 속성을 항상 만족해야 한다.

<dl>
    <dt>신뢰성 있는 전달(reliable delivery)</dt>
    <dd>어떤 메시지도 손실되지 않는다.<br/>메시지는 모든 노드에 전달된다.</dd>
    <dt>전체 순서가 정해진 전달(totally ordered delivery)</dt>
    <dd>메시지는 모든 노드에 같은 순서로 전달된다.</dd>
</dl>

<br/>

#### 전체 순서 브로드캐스트 사용하기
주키퍼나 etcd 같은 합의 서비스는 전체 순서 브로드캐스트를 실제로 구현한다.<br/>
전체 순서 브로드캐스와 합의 사이에는 강한 연관이 있다.

데이터베이스 복제에 전체 순서 브로드캐스트가 필요하다.<br/>
모든 메시지를 같은 순서로 처리하면 복제 서버들이 일관성 있는 상태를 유지한다.<br/>
이 원리를 **상태 기계 복제(state mahcine replication)**이라고 한다.

직렬성 트랜잭션을 구현하는 데도 쓸 수 있다.<br/>
모든 메시지가 스토어드 프로시저로 실행되는 결정적 트랜잭션을 나타낸다면 데이터베이스의 일관성을 유지 할 수 있다.

전체 순서 브로드캐스트의 중요한 측면은 메시지가 전달되는 시점에 순서가 고정되는 점이다.<br/>
메시지를 소급적으로 끼워넣는 게 허용되지 않는다.<br/>
타임스탬프 순서화보다 강한 점이다.

전체 순서 브로드캐스트는 **로그**를 만드는 방법 중 하나이고,<br/>
펜싱 토큰을 제공하는 잠금 서비스를 구현하는데에도 유용하다.

<br/>

#### 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기
전체 순서 브로드캐스트를 추가 전용 로그로 사용해 선형성 compare-and-set 연산을 다음과 같이 구현할 수 있다.

1. 메시지를 로그에 추가해서 사용자명을 가리킨다.
2. 로그를 읽고 추가한 메시지가 되돌아오기를 기다린다.
3. 원하는 사용자명을 점유하려는 첫 번째 메시지가 자신의 메시지라면 성공한 것이다.<br/>
   아니라면 어보트시킨다.
    > 큐에 아래처럼 들어있을 때<br/>
    > <kbd>섭섭<sup>2</sup></kbd> > <kbd>홍홍</kbd> > <kbd>섭섭<sup>1</sup></kbd><br/>
    > <kbd>섭섭<sup>1</sup></kbd>을 해당 노드가 보낸 것이면 성공

이 절차는 선형성 쓰기를 보장하지만 선형성 읽기를 보장하지는 않는다.<br/>
이 절차는 **순차적 일관성(sequential consistency)**나 **타임라인 일관성(timeline consistency)**로 선형성보다 조금 약한 보장을 제공한다.

읽기는 선형적으로 만드는 방법은 아래와 같은 것들이 있다.

- 로그를 통해 순차 읽기를 한다. "읽기" 메시지를 추가하고 되돌아왔을 때 실제 읽기를 수행한다.<br/>
    ex. etcd의 정족수 읽기
- 최신 로그 메시지 위치까지 모든 항목이 전달되기를 기다린 후 읽기를 수행한다.<br/>
    ex. 주키퍼의 sync() 연산
- 쓰기를 실행할 때 동기적으로 갱신되는 복제 서버에서 읽어 온다.<br/>
    연쇄 복제에서 사용된다.

<br/>

#### 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기
앞 절의 반대 방향이다.

원자적 increment-and-get 연산이 지원되는 선형 레지스터가 있다고 가정하는 것이 가장 쉽다.<br/>
원자적 compare-and-set 연산이 있어도 된다.

알고리즘은 전체 순서 브로드캐스트를 통해 보낸고 싶은 모든 메시지에 대해 선형성 정수로 increment-and-get을 수행하고 레지스터에서 얻은 값을 일련번호로 메시지에 붙힌다.<br/>
그 후 메시지를 모든 노드에 보낼 수 있고 수신자들은 일련 번호 순서대로 메시지를 전달한다.

원자적 increment-and-get 연산이 지원되는 선형성 정수를 만드는 가장 쉬운 방법은 노드 하나에 변수 하나로 저장하는 것이다.<br/>
하지만 확장성과 장애 복구 측면에서 불리하다.<br/>
합의 알고리즘은 이를 해결할 수 있다.

아래 3개는 동등하다고 증명할 수 있다.

- 선형성 compare-and-set(또는 increment-and-get) 레지스터
- 전체 순서 브로드캐스트
- 합의

<br/>

## 분산 트랜잭션과 합의 <small class="weak">Distributed Transactions and Consensus</small>
합의의 목적은 비공식적으로 **여러 노드들이 뭔가에 동의하게 만드는 것**이다.

노드가 동의하는 것이 중요한 상황은 아래와 같은 것들이 있다.
<dl>
    <dt>리더 선출</dt>
    <dd>단일 리더 복제를 사용하는 데이터베이스는 어떤 노드가 리더인지 동의해야한다.<br/>이는 스플릿 브레인을 유발할 수 있는 잘못된 복구 장애 복구를 피하는데 중요하다.</dd>
    <dt>원자적 커밋</dt>
    <dd>트랜잭션의 원자성을 유지하고 싶다면 모든 노드가 트랜잭션의 결과에 동의하게 만들어야한다.<br/>모두 커밋되거나 모두 어보트/롤백된다.</dd>
</dl>

이번 절에는 원자적 커밋을 해결하는 가장 흔한 방법인 **2단계 커밋(2PC)**를 배우고 아주 좋은 것이 아닌 것을 알고<br/>
주키퍼(Zab)와 etcd(Raft)에서 쓰이는 더 좋은 합의 알고리즘을 배운다.

<br/>


### 원자적 커잇과 2단계 커밋(2PC) <small class="weak">Atomic Commit and Two-Phase Commit(2PC)</small>

원자적 트랜잭션의 결과는 **커밋**이나 **어보트**다.<br/>
커밋 성공한 경우 트랜잭션에서 쓴 내용은 지속성을 지니며 어보트된 경우 모든 내용은 롤백된다.

<br/>

#### 단일 노드에서 분산 원자적 커밋으로
단일 데이터베이스 노드에서 트랜잭션의 원자성은 흔히 저장소 엔진에서 구현된다.<br/>
커밋을 원자적으로 만들어주는 것은 단일 장치(특정 하나 노드의 특정 디스크 드라이브 컨트롤러)다.

여러 노드를 사용할 경우 각 노드에서 독립적으로 트랜잭션을 커밋하는 것은 충분하지 않다.<br/>
어떤 노드에서는 커밋하고 어떤 노드에서는 실패해서 원자성 보장을 위반하기 쉽다.

- 제약 조건 위반이나 충돌은 감지해서 일부 어보트, 일부 커밋
- 네트워크 손실로 인한 타임아웃으로 일부 어보트, 일부 커밋
- 노드 재시작으로 인한 일부 어보트, 일부 커밋

트랜잭션 커밋은 되돌릴 수 없어야 한다. 소급적으로 어보트는 허용되지 않는다.<br/>
커밋된 데이터가 다른 트랜잭션에서 보이고 다른 클라이언트는 해당 데이터에 의존적이될 수 있기 때문이다.<br/>
234쪽 "커밋 후 읽기" 격리의 기반을 형성한다.

커밋된 트랜잭션을 나중에 **보상 트랜잭션(compensating transaction)**이 취소하는 것은 가능하다.<br/>
이는 단지 별개의 트랜잭션일 뿐이다.

<br/>

#### 2단계 커밋 소개
2단계 커밋은 여러 노드에 걸친 원자적 트래잭션 커밋을 달성하는 알고리즘이다.<br/>
즉, 모든 노드가 커밋되거나 모든 노드가 어보트되도록 보장한다.

일부 데이터베이스에서는 2PC가 내부적으로 사용되고 **XA 트랜잭션**(예를 들어 자바 트랜잭션 API에서 지원)의 형태나 SOAP 웹 서비스용 WS-AtomicTransaction을 통해 애플리케이션에서도 사용할 수 있다.

2PC는 **코디네이터**\(**coordinator**, 트랜잭션 관리자라고도 한다\)를 사용한다.<br/>
코디네이터는 클라이언트 라이브러리 형태로 구현되거나 분리된 프로세스나 서비스가 될 수 있다.<br/>
코디네이터 서비스의 예로 Narayana, JOTM, BTM, MSDTC가 있다.

<img src="{{ "../assets/img/study/books/data-intensive-applications/chapter09/section3-4/2pc.png" | relative_url }}" alt="image" width="700px" />

2PC 트랜잭션은 여러 데이터베이스 노드에서 데이터를 읽고 쓰면서 시작한다.<br/>
각 노드는 트랜잭션의 **참여자(participant)**라고 부른다.<br/>
애플리케이션이 커밋할 준비가 되면 코디네이터가 1단계를 시작한다.<br/>
각 노드에 **준비** 요청을 보내서 커밋할 수 있는지 물어본다.

- 모든 참여자가 커밋할 준비 "네"를 응답하면 코디네이터는 2단계에서 **커밋** 요청을 보내고 커밋이 실제로 일어난다.
- 참여자 중 누구라도 "아니오"로 응답하면 코디네이터는 2단계에서 모든 노드에 **어보트** 요청을 보낸다.

<br/>

#### 약속에 관한 시스템
1단계 커밋은 원자성을 보장하지 못하지만 2단계 커밋은 보장하는지는 아래 과정을 살펴보면 알 수 있다.

1. 애플리케이션은 코디네이터로부터 전역적으로 유일한 트랜잭선 ID를 받는다.
2. 각 참여자에서 단일 노드 트랜잭션을 시작하고 뭔가 잘못되면 모두 어보트한다.
3. 모든 참여자에게 전역 트랜잭션 ID에 대한 준비 요청을 보낸다. 요청 중 실패한 것이 있으면 코디네이터는 모든 참여자에게 어보트 요청을 보낸다.
4. 참여자가 준비 요청을 받으면 모든 상황에서 분명히 트랜잭션을 커밋할 수 있을 때만 "네"라고 응답한다.
5. 코디네이터가 모든 준비 요청 응답을 받으면 트랜잭션의 커밋 또는 어보트 결정을 내리고 기록한다.<br/>
    이를 **커밋 포인트**라고 한다.
6. 코디네이터 결정이 기록되면 모든 참여자에게 커밋이나 어보트 요청이 전송된다.<br/>
   요청이 실패하면 영원히 재시도 한다.

코디네이터가 커밋 요청을 보냈을 경우 각 참여자가 커밋을 약속했으므로 반드시 수행함으로써 원자성을 보장할 수 있다.

<br/>

#### 코디네이터 장애
참여자가 준비 요청에 "네"로 투표하고 코디네이터가 죽거나 네트워크 장애가 나면 참여자는 기다릴 수밖에 없다.<br/>
이 상태에 있는 참여자의 트랜잭션을 **의심스럽다(in doubt)** 또는 **불확실하다(uncertain)**고 한다.<br/>
각 노드는 다른 노드와의 일관성을 위해 커밋이나 어보트를 스스로 결정할 수 없다.<br/>
2PC가 완료할 수 있는 유일한 방법은 코디네이터가 복구되기를 기다리는 것뿐이다.<br/>
코디네이터가 복구될 때 트랜잭션 로그를 읽어서 모든 의심스러운 트랙잭션들의 상태를 결정한다.<br/>
코디네이터의 로그에 커밋 레코드가 없는 트랜잭션들은 어보트된다.

<br/>

#### 3단계 커밋
2단계 커밋은 코디네이터가 복구하기를 기다리느라 멈출 수 있어서 **블로킹** 원자적 커밋 프로토콜이라 불린다.<br/>
이론상으로 노드가 장애 나도 멈추지 않도록 원자적 커밋 프로토콜을 **논클로킹**하게 만들 수 있으나 쉽지 않다.

2PC의 대안으로 **3단계 커밋(3PC)**이라는 알고리즘이 제안됐다.<br/>
3PC는 지연에 제한이 있는 네트워크와 응답 시간에 제한이 있는 노드를 가정한다.

논블로킹 원자적 커밋은 일반적으로 **완벽한 장애 감지기(perfect failure dectector)**가 필요하다.<br/>
타임아웃은 신뢰성 있는 장애감지기가 아닌데, 아무 노드도 안 죽었지만 네트워크 문제로 요청이 타임아웃될 수 있기 대문이다.<br/>
이런 까닭으로 코디네이터 장애 문제에 불구하고 2PC가 계속 쓰인다.

<br/>

### 현실의 분산 트랜잭션 <small class="weak">Distributed Transactions in Practice</small>
분산 트랜잭션은 중요한 안전성 보장을 제공한다는 좋은 평가와<br/>
운영상의 문제를 일으키고 성능을 떨어뜨리며 과장된 약속을 한다고 비판받는다.

마이SQL의 분산 트랜잭션은 단일 노드의 것보다 10배 이상 느리다.<br/>
2단계 커밋의 많은 성능 비용은 장애 복구를 위한 디스크 강제 쓰기(fsync)와 부가적인 네트워크 왕복 시간 때문이다.

분산 트랜잭션은 2가지 다른 종류가 있다.

<dl>
    <dt>데이터베이스 내부 분산 트랜잭션</dt>
    <dd>모든 노드가 동일한 데이터베이스 소프트웨어를 실행하는 경우이다.</dd>
    <dt>이종 분산 트랜잭션</dt>
    <dd>이종(heterogeneous) 트랜잭션에서 참여자들은 둘 이상의 다른 기술이다.<br/>서로 다른 벤더 또는 메시지 브로커처럼 비데이터베이스 시스템일 수 있다.</dd>
</dl>

<br/>

#### 정확히 한 번 메시지 처리
이종 분산 트랜잭션은 다양한 시스템들이 강력한 방법으로 통합될 수 있게 한다.<br/>
예를 들어 메시지 큐에서 나온 메시지는 그 메시지를 처리하는 데이터베이스 트랜잭션 커밋이 성공했을 때만 처리된 것으로 확인받을 수 있다.

메시지 전달이나 데이터베이스 트랜잭션 중 하나 이상이 실패하면 둘 다 어보트되고 메시지 브로커는 나중에 메시지를 안전하게 전달할 수 있다.<br/>
이를 통해 메시지가 결과적으로 정확히 한 번(exactly once) 처리되도록 보장할 수 있다.

11장에서 정확히 한 번 메시지 처리 주제를 다시 설명한다.<br/>
먼저 이종 분산 트랜잭션을 가능하게 하는 원자적 커밋 프로토콜을 살펴본다.

<br/>

#### XA 트랜잭션
[**X/Open XA(eXtended Architcture)**](https://en.wikipedia.org/wiki/X/Open_XA)는 이종 기술에 걸친 2단계 커밋을 구현하는 표준이다.<br/>
XA는 1991년에 소개됐고 널리 구현되어 여러 전통적 RDB(PostgresQL, MySQL, DB2, SQLServer, Oracle)와<br/><span class="question" title="Apache Kafka는 지원하지 않는다.">여러 메시지 브로커(ActiveMQ, HornetQ, MSMQ, IMB MQ)</span>에서 지원된다.

XA는 트랜잭션 코디네이터와 연결되는 인터페이스를 제공하는 C API다.<br/>
다른 언어에도 바인딩이 있다.<br/>
Jave EE에서 XA 트랜잭션은 Java Transaction API(JTA)를 사용해 구현되며 JTA는 Java Database Connectivity(JDBBC)를 사용하는 데이터베이스 드라이버 다수와 Java Message Service(JMS) API를 사용하는 메시지 브로커 드라이버에서 지원된다.

XA는 애플리케이션이 네트워크 드라이버나 클라이언트 라이브러리를 사용해 참여자 데이터베이스나 메시징 서비스와 통신한다고 가정한다.<br/>
드라이버는 XA API를 호출하여 연산이 분산 트랜잭션의 일부가 되어야하는지 확인한다.<br/>
그렇다면 필요한 정보를 보내고, 코디네이터로부터 요청을 받을 수 있는 콜백을 제공한다.<br/>
콜백의 종류에는 준비, 커밋, 어보트가 있다.

코디네이터는 XA API를 구현한다. 애플리케이션 라이브러리로 구현되는 경우도 있다.<br/>
코디네이터는 트랜잭션 참여자를 추적하고 준비 요청과 응답 수집, 커밋/어보트 결정을 내리고 기록한다.

애플리케이션이 죽으면 코디네이터도 함께 사라진다.<br/>
서버가 재시작되며 코디네이터 라이브러리가 기록한 커밋 포인트를 읽어서 참여자들에게 적절히 커밋 또는 어보트 요청을 보낼 수 있다.

<br/>

#### 의심스러운 상태에 있는 동안 잠금을 유지하는 문제
2단계 커밋을 사용할 때 트랜잭션은 의심스러운 상태에 있는 동안 내내 잠금을 유지해야 한다.<br/>
데이터베이스 트랜잭션은 보통 더티 쓰기를 막기 위해 그들이 변경한 로우에 로우 수준의 독점적인 잠금을 획득하기 때문이다.

<br/>

#### 코디네이터 장애에서 복구하기
이론상으로는 코디네이터가 재시작하면 로그로부터 그 상태를 깨끗하게 복구하고 의심스러운 트랜잭션을 해소해야한다.<br/>
현실에서는 **고아가 된(orphaned)** 의심스러운 트랜잭션이 생길 수 있다.<br/>
이를 해결하는 유일한 방법은 관리자가 수동으로 트랜잭션을 커밋 또는 어보트하는 것이다.

여러 XA 구현에는 참여자가 코디네이터로부터 확정적 결정을 얻지 않고 의심스러운 트랜잭션을 어보트하거나 커밋할지 결정할 수 있는 **경험적 결정(heuristic decision)**을 지원한다.<br/>
이는 아마도 원자성을 깰 수 있으므로 큰 장애 상황을 벗어나고자 할 때만 쓰도록 의도된 것이다.

<br/>

#### 분산 트랜잭션의 제약
XA 트랜잭션은 여러 데이터 시스템이 일관성을 유지하게 해주는 이점이 있지만 운영상의 문제도 있다.<br/>
핵심 구현은 코디네이터 자체가 일종의 데이터베이스여야하는 점이다.

- 코디네이터가 복제되지 않으면 **단일 장애점**(single point of failure)가 된다.
- 여러 서버 사이드 애플리케이션은 상태 비저장 모드로 개발되는데 코디네이터는 **상태 저장** 서비스라 통합이 간단하지 않다.
- XA는 여러 데이터 시스템과 호환되는 **최소 공통 분모**이고 교착 상태 감지, 직렬성 스냅숏 격리(SSI)와 함께 동작하지 않는다.
- 분산 트랜잭션은 모든 참여자가 응답해야하므로 **장애를 증폭**시키는 경향이 있다. 내결함성을 지닌 시스템을 구축하려는 목적에 어긋난다.

<br/>

### 내결함성을 지닌 합의 <small class="weak">Fault-Tolerant Consensus</small>
합의 문제는 다음처럼 형식화될 수 있다.<br/>
하나 이상의 노드들이 값을 **제안할** 수 있고 합의 알고리즘이 그 값들 중 하나를 **결정한다**.

합의 알고리즘은 다음 속성을 만족해야 한다.
<dl>
    <dt>균일한 동의</dt>
    <dd>어떤 두 노드도 다르게 결정하지 않는다.</dd>
    <dt>무결성</dt>
    <dd>어떤 노드도 두 번 결정하지 않는다.</dd>
    <dt>유효성</dt>
    <dd>한 노드가 값 v를 결정한다면 v는 어떤 노드에서 제안된 것이다.</dd>
    <dt>종료</dt>
    <dd>죽지 않은 모든 노드는 결국 어떤 값을 결정한다.</dd>
</dl>

내결함성이 상관없다면 한 노드를 "독재자"로 하드코딩하고 모든 결정을 내리게하면 된다.<br/>
하지만 그 노드에 장애가 나면 그 시스템은 어떤 결정도 내릴 수 없다.

<br/>

#### 합의 알고리즘과 전체 순서 브로드캐스트
내결함성을 지닌 합의 알고리즘 중 널리 알려진 것은 뷰스탬프 복제(Viewstamped Replication, VSR), 팍소스(Paxos), 라프트(Raft), 잽(Zab)이다.<br/>
이 알고리즘 대다수는 값의 **순차열(sequence)**에 대해 결정해서 **전체 순서 브로드캐스트** 알고리즘을 만든다.<br/>
전체 순서 브로드캐스트는 합의를 여러 번 반복하는 것과 동일하다(각 합의 결정이 하나의 메시지 전달에 해당한다).

- 합의의 동의 속성 때문에 모든 노드는 같은 메시지를 같은 순서로 전다하도록 결정한다.
- 무결성 속성 때문에 메시지는 중복되지 않는다.
- 유효성 속성 때문에 메시지는 오염되지 않고 난데없이 조작되지 않는다.
- 종료 속성 때문에 메시지는 손실되지 않는다.

뷰스탬프 복제, 라프트, 잽은 전체 순서 브로드캐스트를 직접 구현한다.<br/>
팍소스의 최적화 구현은 다중 팍소스(Multi-Paxos)라고 한다.

<br/>

#### 단일 리더 복제와 합의
리더를 운영자가 수동으로 선택하면 "독재자" 합의 알고리즘이 사용된 것이다.<br/>
어떤 데이터베이스는 자동 리더 선출과 자동 복구를 수행한다.<br/>
스플릿 브레인 문제를 해결하려면 리더가 필요한 것으로 보인다.<br/>
이는 다음 절에서 해결한다.

<br/>

#### 에포크 번호 붙이기와 정족수
합의 프로토콜들은 에포크 번호(epoch number)를 정의하고 각 에포크 내에서는 리더가 유일하다고 보장한다.<br/>
에포크 번호는 팍소스에서 투표 번호(ballot number), 뷰스탬프 복제에서 뷰 번호(view number), 라프트에서 텀 번호(term number)라고 한다.

현재 리더가 죽었을 때 새 노드를 선출하기 위해 투표가 시작된다.<br/>
선출은 에포크 번호를 단조 증가시킨다.<br/>
두 가지 다른 에포크에 있는 리더들 사이에 충돌이 있으면 에포크 번호가 높은 리더가 이긴다.

리더의 모든 제안은 노드의 **정족수(quorum)**로부터 투표받아야 한다.<br/>
노드는 에포크 번호가 더 높은 리더를 알지 못할 때만 제안에 찬성하는 투표를 한다.

따라서 두 번의 투표가 있다.<br/>
한 번은 리더를 선출하기 위해, 두 번째는 리더의 제안에 투표하기 위해서다.<br/>
제안에 대한 투표가 성공하려면 투표한 노드 중 최소 하나는 가장 최근의 리더 선출에도 참여했어야 한다.


<br/>

#### 합의의 제약
합의 알고리즘은 불확실한 시스템에 안전성 속성(동의, 무결성, 유효성)을 가져오고 내결함성을 유지한다.<br/>
전체 순서 브로드캐스트를 제공하고 내결함성 있는 방식으로 원자적 연산을 구현할 수도 있다.

하지만 합의 알고리즘은 대가가 따른다.<br/>
제안이 결정되기 전 노드들의 투표는 동기식 복제라 성능에 영향을 준다.<br/>
합의 시스템은 항상 엄격한 과반수가 동작하기를 요구한다.<br/>
대부분의 합의 알고리즘은 유권자 노드 집합이 고정돼있다고 가정하여 **동적 멤버십(dynamic membership)** 확장은 정적 멤버십 알고리즘보다 이해하기 어렵다.

합의 시스템은 장애 노드를 감지하기 위해 타임아웃에 의존하는데<br/>
네트워크 지연의 변동이 심한 환경에서 불필요한 잦은 리더 선출로 성능 손해가 발생할 수 있다.

<br/>

### 멤버십과 코디네이션 서비스 <small class="weak">Membership and Coordination Services</small>
주키퍼나 etcd는 분산 키-값 저장소나 코디네이션과 설정 서비스라고 종종 설명된다.<br/>
다른 종류의 데이터베이스와 다른 점은 내결함성을 지닌 전체 순서 브로드캐스트 알고리즘을 구현한 점이다.

주키퍼는 전체 순서 브로드캐스트 뿐만 아니라 분산 시스템 구축에 유용한 기능을 구현한다.
주키퍼는 구글의 Chubby 잠금 서비스를 모델로 삼았다.

<dl>
    <dt>선형성 원자적 연산</dt>
    <dd>원자적 compare-and-set 연산 사용해 잠금을 구현할 수 있다.<br/>분산 잠금은 만료 시간이 있는 <strong>임차권(lease)</strong>로 구현된다.</dd>
    <dt>연산의 전체 순서화</dt>
    <dd>잠금의 충돌을 막기 위해 펜싱 토큰이 필요한데, 펜싱 토큰은 잠금을 획득할 때마다 단조 증가하는 숫자다.<br/>주키퍼는 모든 연산에 전체 순서를 정하고 각 연산에 단조 증가하는 트랜잭션 ID(zxid)와 버전 번호(cversion)를 할당한다.</dd>
    <dt>장애 감지</dt>
    <dd>클라이언트와 주키퍼는 주기적으로 heartbeat를 교환해서 살아있는지 확인한다.<br/>세션 타임아웃보다 긴 기간동안 heartbeat가 멈추면 세션이 죽었다고 선언한다.<br/>세션에서 획득한 잠금은 세션 타임아웃 시 자동으로 해제되도록 할 수 있다(ephermeral node).</dd>
    <dt>변경 알림</dt>
    <dd>다른 클라이언트가 언제 클러스터에 합류했는지 혹은 다른 클라이언트가 장애가 났는지 알림을 구독함으로써 알아챌 수 있다.</dd>
</dl>

이 기능 중에서 오직 선형성 원자적 연산만 실제로 합의가 필요하다.

<br/>

#### 작업을 노드에 할당하기
주키퍼/처비 모델이 잘 동작하는 예는 여러 개의 서비스 중 하나가 리더로 선택돼야 할 때다.<br/>
또 다른 예는 파티셔닝된 자원 중 어떤 파티션을 어떤 노드에 할당해야할지 결정해야하는 경우다.

주키퍼를 사용하면 내결함성을 구현할 수 있지만 쉽지 않으므로<br/>
[아파치 큐레이터](https://curator.apache.org/docs/about/)와 같은 주키퍼 클라이언트 API 위의 고수준 도구를 사용할 수 있는데 그래도 쉽지 않다.

보통 주키퍼로 관리되는 데이터의 종류는 매우 느리게 변한다(몇 분 혹은 몇 시간 단위).

<br/>

#### 서비스 찾기
주키퍼, etcd, [Consul](https://www.consul.io/)은 **서비스 찾기(service discovery)** 용도로 자주 사용된다.<br/>
서비스 찾기는 합의가 필요없지만 리더 선출은 합의가 필요하다.<br/>
합의 시스템이 누가 리더인지 이미 안다면 리더가 누구인지 빠르게 찾을 수 있도록 어떤 합의 시스템은 읽기 전용 캐시 복제 서버를 지원한다.
<br/>

#### 멤버십 서비스
주키퍼와 유사 프로젝트들은 오랜 **멤버십 서비스(membership service)** 연구 역사의 일부로 볼 수 있다.

멤버십 서비스는 클러스터에서 어떤 노드가 현재 활성화된 살아 있는 멤버인지 결정한다.<br/>
8장에서 본 것처럼 기약 없는 네트워크 지연으로 신뢰성 있는 노드 장애는 불가능하다.<br/>
장애 감지를 합의와 연결하면 어떤 노드가 살았는지 혹은 죽었는지 동의할 수 있다.

<br/>

## 정리
일관성과 합의에 관한 주제를 다뤘다.

시스템에서 발생한 이벤트에 순서를 부과하는 인과성도 살펴봤다.

사용자명의 유일한 등록은 합의 문제로 이어진다.

합의를 달성하는 것은 결정되 것에 모든 노드가 동의하고 결정을 되돌릴 수 없는 방식으로 뭔가를 결정하는 것이다.

합의와 동치인 문제는 아래와 같다.

<dl>
    <dt>선형성 compare-and-set 레지스터</dt>
    <dd>현재 값과 매개변수의 일치 여부에 따라 값을 설정할지 말지 원자적으로 결정해야 한다.</dd>
    <dt>원자적 트랜잭션 커밋</dt>
    <dd>분산 트랜잭션을 커밋 또는 어보트할지 결정해야 한다.</dd>
    <dt>전체 순서 브로드캐스트</dt>
    <dd>메시지를 전달할 순서를 결정해야 한다.</dd>
    <dt>잠금과 임차권</dt>
    <dd>잠금을 누가 획득할지 결정한다.</dd>
    <dt>멤버십/코디네이션 서비스</dt>
    <dd>장애 감지기가 주어지면 시스템은 어떤 노드가 살았는지 죽었는지 결정해야 한다.</dd>
    <dt>유일성 제약 조건</dt>
    <dd>여러 트랜잭션들이 동시에 같은 키로 레코드를 생성하려 할 때 어떤 것은 허용하고 실패할 것인지 결정한다.</dd>
</dl>

이런 결정들은 노드가 하나만 있거나 하나의 노드만 결정하면 간단하다.

이런 시스템은 단일 리더에 장애가 나거나 네트워크가 끊기면 진행이 되지 않는다.

이 경우 처리하는 세 가지 방법이 있다.

1. 리더가 복구될 때까지 기다리고 시스템이 그동안 차단되는 것을 받아들인다.
2. 사람이 새 리더 노드를 선택하고 시스템이 그 노드를 사용하도록 재설정해서 수동으로 장애 복구를 한다.
3. 자동으로 새 리더를 선택하는 알고리즘을 사용한다.

단일 리더 데이터베이스는 리더십 유지 및 변경 이전까지 합의를 사용하지 않지만 결국은 합의가 필요하다.

주키퍼 같은 도구는 합의, 장애 감지, 멤버십 서비스를 위탁하는데 중요한 역할을 수행한다.

모든 시스템이 합의가 필요한 것은 아니다. 예를 들어 리더 없는 복제 시스템과 다중 리더 복제 시스템은 보통 전역 합의를 사용하지 않는다.

<br/>

<img src="{{ "../assets/img/study/books/data-intensive-applications/chapter09/section3-4/consensus.png" | relative_url }}" alt="image" width="640px" />

<br/>
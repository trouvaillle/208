---
layout: post
title:  "09. 일관성과 합의 - Section 3, 4"
date:   2024-10-09 22:00:00 +0900
categories: study books data-intensive-applications
author: 유석모
announced_on: 2024년 10월 10일
---
## 순서화 보장 <small class="weak">Ordering Guarantees</small>
<aside mark="💡">
<strong>순서화</strong>란 여러 요소가 있을 때 선후 관계를 결정하는 것이다.
</aside>

선형성 레지스터는 한 부의 데이터만 존재하는 것처럼 행동하고 이는 한 순간에 하나의 동작만 원자적으로 수행되는 것처럼 보인다. 이는 연산들이 정해진 순서대로 동작하는 것을 의미한다.

- 5장의 단일 리더 복제에서 리더의 주 목적은 **쓰기의 순서**를 결정하여 쓰기 충돌을 방지하는 것이다.
- 7장의 직렬성은 트랜잭션들이 **일련 순서**에 따라 실행되는 것처럼 보장하는 것이다.
- 9장의 분산 시스템에서 **타임스탬프**를 사용하는 것은 순서화로 볼 수 있다.

순서화, 선형성, 합의 사이에는 깊은 연결 관계가 있다.

<br/>

### 순서화와 인과성 <small class="weak">Ordering and Causality</small>

순서화는 **인과성**을 보존하는데 도움을 준다.

- 167쪽 "일관된 순서로 읽기"에서 질문보다 응답을 먼저 보는 경우 인과를 위반한다. 질문과 답변 사이에 **인과적 의존성(causal dependency)**가 있다고 한다.
- 5장에서 네트워크 지연으로 인해 존재하지 않는 로우를 갱신하는 경우 인과를 위반한다. 여기서 인과성은 로우가 갱신되기 전에 먼저 생성돼야 함이다.
- 186쪽 "동시 쓰기 감지"에서 두 개의 연산 A와 B가 있을 때 둘 중 하나가 먼저 실행되면 **이전 발생(happened before)** 관계가 있음을 알 수 있다. A가 B보다 먼저 실행됐다면 B는 A에 인과적 연결을 가질 수 있다.
- 236쪽 "스냅숏 격리와 반복 읽기"에서 트랙잭션은 일관된 스냅숏으로부터 읽는다고 했다. 이는 **인과성에 일관적(consistent with casuality)**라는 의미다.
- 246쪽 "쓰기 스큐와 팬텀"에서 쓰기 스큐는 트랜잭션 사이의 인과적 의존성을 추적함으로써 검출한다.
- 9장의 축구를 보는 예제에서 앨리스가 결과를 외치고 밥이 뒤처진 결과를 보는 것은 인과성 위반이다.

<aside mark="💡">
<strong>인과성</strong>은 이벤트에 순서를 부과한다.<br/>
무엇이 무엇보다 먼저 일어났는가를 정의한다.
</aside>


시스템이 인과성에 의해 부과된 순서를 지키면 **인과적으로 일관적(causally consistent)**이라고 한다. 스냅숏 격리는 인과적 일과성을 제공한다.

<br/>

#### 인과적 순서가 전체 순서는 아니다

**전체 순서(total order)**는 항상 두 요소의 크고 작은 관계를 결정할 수 있다.

<dl>
    <dt>선형성</dt>
    <dd>선형성 시스템에서는 연산의 <strong>전체 순서</strong>를 정할 수 있다.<br/>타임라인이 하나다.</dd>
    <dt>인과성</dt>
    <dd>두 연산이 동시적이면 순서를 비교할 수 없다.<br/>타임라인이 1개 이상이다.</dd>
</dl>

<img src="{{ "../assets/img/study/books/data-intensive-applications/chapter09/section3-4/git-branch.png" | relative_url }}" alt="image" style="background: white; padding: 1rem;"/>

인과적 의존성 그래프는 깃의 버전 히스토리와 유사하다.<br/>
서로 다른 브랜치의 순서는 정할 수 없지만 동일 브랜치의 부분 순서는 정의할 수 있다.

<br/>

#### 선형성은 인과적 일관성보다 강하다

선형성은 인과성을 **내포한다**. 즉, 선형적이면 인과적이다.<br/>
333쪽 "선형성의 비용"과 같이 선형성은 네트워크 지연이 크면 성능과 가용성에 해가 될 수 있다.

선형성은 인과성을 보존하는 유일한 방법이 아니다.<br/>
인과적 일관성은 선형성보다 효율적으로 구현될 수 있다.

<aside mark="💡">
선형성이 필요한 것처럼 보이는 다수의 시스템에 진짜로 필요한 것은 <strong>인과적 일관성</strong>이다.<br/>
</aside>

<br/>

#### 인과적 의존성 담기
인과성을 유지하기 위해 어떤 연산이 다른 연산보다 **먼저 실행됐는지** 알아야 한다.<br/>
대표적인 기법은 186쪽 "동시 쓰기 감지"처럼 **버전 벡터**를 활용하는 것이다.<br/>
단일 키뿐만 아니라 전체 데이터베이스에 걸친 의존성을 추적해야 하므로 버전 벡터를 일반화해야한다.

260쪽 "직렬성 스냅숏 격리(SSI)"에서 충돌 검출에서도 비슷한 아이디어가 나타난다.<br/>
트랜잭션이 커밋을 원할 때 데이터베이스는 읽은 데이터의 버전이 여전히 최신인지 확인한다.

<br/>

### 일련번호 순서화 <small class="weak">Sequence Number Ordering</small>

**일련번호**나 **타임스탬프**를 써서 이벤트의 순서를 정할 수 있다.<br/>
타임스탬프는 일 기준 시계대신 **논리적 시계**에서 얻어도 된다.<br/>
논리적 시계는 일련번호를 생성하는 알고리즘이고 보통 카운터를 사용한다.

일련번호나 타임스탬프는 크기가 작고 **전체 순서**를 제공한다.<br/>
항상 두 개의 일련번호를 비교해서 선후 관계를 결정할 수 있다.<br/>
특히 **인과성에 일관적인** 전체 순서대로 일련번호를 생성할 수 있다.

인과성에 일과적이지 않은 전체 순서의 예시는 UUID 부여로 인과에 대한 아무 의미도 없다.

<br/>

#### 비인과적 일련번호 생성기

단일 리더가 없는 경우 아래와 같은 방법을 통해 일련번호를 생성할 수 있다.
하지만 **인과성에 일관적이지 않다**.

<dl>
    <dt>노드 별 독립적인 일련번호 생성</dt>
    <dd>두 노드가 있다면 하나는 홀수, 하나는 짝수 일련번호를 생성한다.<br/>일련번호의 이진 표현에서 앞의 몇 비트를 예약하면 서로 다른 노드에서 일련번호의 유일성이 보장된다.<br/>⚠️ 각 노드의 초당 연산수가 달라 다른 노드 간의 선후 연산을 알 수 없다.</dd>
    <dt>물리적 시계에서 얻은 타임스탬프</dt>
    <dd>해상도가 충분히 높다면 전체 순서를 정할 수도 있다.<br/><span title="291쪽 &quot;이벤트 순서화용 타임스탬프&quot; 참고">최종 쓰기 승리 충돌 해소 방법에서도 사용된다.</span><br/>⚠️ 물리적 시계는 시계 스큐에 종속적이어서 인과성에 일관적이지 않게 될 수 있다. 그림 8-3이 그 사례다.</dd>
    <dt>블록 할당자</dt>
    <dd>노드 A는 1~1,000, 노드 B는 1,000~2,000까지의 블록을 차지한다.<br/>각 노드는 독립적으로 자신의 블록에서 일련번호를 배정한다.<br/>⚠️ 1001 연산이 1 연산보다 먼저 발생했을 수 있다.</dd>
</dl>

<br/>

#### 램포트 타임스탬프 <small class="weak">Lamport Timestamp</small>

램포트 타임스탬프(Lamport timestamp)는 **인과성에 일관적인** 일련번호를 생성하는 간단한 방법이다.<br/>
램포트 타임스탬프는 **(카운터, 노드 ID)**의 쌍이다.

램포트 타임스탬프는 전체 순서화를 제공한다.<br/>
카운터가 큰 것이 타임스탬프가 크고, 카운터 값이 같으면 노드 ID가 큰 것이 타임스탬프가 크다.

모든 노드와 클라이언트가 지금까지 본 카운터 값 중 **최댓값**을 추적하고 모든 요청에 그 최댓값을 포함시키는 것이 인과성에 일관적으로 만들어주는 핵심 아이디어다.<br/>
노드가 자신의 카운터 값보다 큰 최대 카운터를 가진 요청이나 응답을 받으면 그 최댓값으로 카운터를 증가시킨다.

186쪽 "동시 쓰기 감지"에서 봤던 버전 벡터와 혼동된다.<br/>
버전 벡터는 두 연산이 동시적인지 또는 인과적으로 의존하는알 수 있다.<br/>
램포트 타임스탬프의 전체 순서화로부터 두 연산이 동시적인지 또는 인과적으로 의존성이 있는지는 알 수 없다.

<img src="{{ "../assets/img/study/books/data-intensive-applications/chapter09/section3-4/lamport-timestamp.png" | relative_url }}" alt="image" />

<br/>

#### 타임스탬프 순서화로는 충분하지 않다
사용자명에 대한 유일성 제약 조건 같은 것을 구현하면 연산의 전체 순서가 있는 것으로는 충분하지 않다.<br/>
사후에 성공하는 쪽은 결정할 수는 있지만 **당장** 결정해야할 때는 전체 순서로 부족하다.<br/>
언제 전체 순서가 확정되는지 알아야한다.<br/>
이는 **전체 순서 브로드캐스트**의 주제로 이어진다.

<br/>

### 전체 순서 브로드캐스트 <small class="weak">Total Order Broadcast</small>
단일 CPU 코어 또는 단일 리더는 연산의 전체 순서를 정하기 쉽다.<br/>
처리량이 단일 리더의 허용량을 초과할 경우 시스템을 확장하거나 장애 시 복구를 어떻게 처리할 것인가가 어려운 문제다.<br/>
이는 **전체 순서 브로드캐스트(total order broadcast)**나 **원자적 브로드캐스트(atomic broadcast)**로 알려져 있다.

전체 순서 브로드캐스트는 보통 노드 사이에 메시지를 교환하는 프로토콜로 기술된다.<br/>
비공식적으로 두 가지 안전성 속성을 항상 만족해야 한다.

<dl>
    <dt>신뢰성 있는 전달(reliable delivery)</dt>
    <dd>어떤 메시지도 손실되지 않는다.<br/>메시지는 모든 노드에 전달된다.</dd>
    <dt>전체 순서가 정해진 전달(totally ordered delivery)</dt>
    <dd>메시지는 모든 노드에 같은 순서로 전달된다.</dd>
</dl>

<br/>

#### 전체 순서 브로드캐스트 사용하기


<br/>


## 분산 트랜잭션과 합의 <small class="weak">Distributed Transactions and Consensus</small>

<br/>


### 원자적 커잇과 2단계 커밋(2PC) <small class="weak">Atomic Commit and Two-Phase Commit(2PC)</small>

<br/>

### 현실의 분산 트랜잭션 <small class="weak">Distributed Transactions in Practice</small>

<br/>

### 내결함성을 지닌 합의 <small class="weak">Fault-Tolerant Consensus</small>

<br/>

### 멤버십과 코디네이션 서비스 <small class="weak">Membership and Coordination Services</small>

<br/>


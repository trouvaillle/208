---
layout: post
title:  "04. 부호화와 발전 - Section 2"
date:   2024-07-30 00:00:00 +0900
categories: study books data-intensive-applications
author: 
announced_on: 2024년 7월 30일
---

## 데이터플로 모드
- 데이터플로는 매우 추상적인 개념으로서 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 방법

## 데이터베이스를 통한 데이터플로
- 데이터베이스에 기록할때 부호화, 읽을때 복호화를 한다.
- 데이터베이스에 접근하는 단일 프로스세스가 있다고 가정하면 읽기는 단순히 동일 프로세스의 최신 버전이나 데이터베이스에 뭔가 저장하는것은 미래의 자신에게 메시지를 보내 것이라 할수있다
- 이때 하위 호환성이 필요하다. 그렇지 않으면 이전에 기록한 내용을 미래의 자신이 복호화할 수 없다
- 예를 들어 새로운 버전을 배포할때 지난 버전의 인스턴스 존재할 경우 하위/상위 호환이 안될 경우 문제가 발생한다
    - 새로운 enum을 추가한다던가.. 호환이 안된다면 현기증이 날수도 있다

![데이터 유실 예시]({{ "/assets/img/study/books/data-intensive-applications/chapter04/section2-3/figure01.png" | relative_url }})

## 다양한 시점에 기록된 다양한 값
- 애플리케이션은 배포할 때 몇분이면 새로운 버전으로 대체할 수 있지만 데이터베이스는 그렇지 않다
- 명시적으로 삭제하지 않는 이상 몇년 전 데이터도 그대로 남아 있고 이를 *데이터가 코드보다 더 오래산다* 라고 한다
- 데이터를 새로운 스키마로 다시 기록(마이그레이션)하는 작업은 가능하나 대용량 데이터셋 대상으로는 값비싼 작업이기에 이런 상황을 피한다
- 관계형 DB에서 이러한 경우 대부분 새로운 컬럼을 추가하는 간단한 스키마 변경을 허용한다

## 서비스를 통한 데이터 플로: REST와 RPC
- 네트워크를 통해 통신해야 하는 프로세스중 가장 일반적인 방법은 클라이언트 - 서버 두 역할로 배치한다
- 서버는 네트워크를 통해 API를 공개, 클라이언트는 이 API 요청을 만들어 서버에 연결할 수 있다
    - 이렇게 제공되는 API를 서비스 라고 한다
- 클라이언트로는 웹 브라우저/ 모바일 디바이스 / PC 등 여러가지 수단이 있고, 서버 자체가 다른 서비스의 클라이언트가 될 수 있다
- 이러한 접근 방식은 보통 대용량 어플리케이션을 소규모 서비스로 나누는데 사용하고 이런 서비스 방식을 전통적으로 *서비스 지향 설계(SOA)* 라고 불렀으며 이를 더욱 개선하여 *마이크로서비스 설계(MSA)란 이름으로 재탄생했다
- 서비스와 데이터베이스는 유사한 점이 많다. 클라이언트가 서버에 질의하고 응답을 하듯 데이터베이스도 비슷하다
    - 비즈니스 로직의 존재가 차이
- 서비스 지향 및 마이크로 서비스 아키텍쳐의 핵심 목표는 서비스르 배포와 변경에 독립적으로 만들어서 변경과 유지보수를 더 쉽게 할 수 있게 만드는 것이다
- 예를 들어 각 서비스는 한 팀이 소유해야하고 해당 팀은 다른 팀과의 조정없이 자주 서비스의 새로운 버전을 출시 할 수 있어야한다
    - 우린 옆팀에서 공통 모델을 바꾸는데..?
- 다시 말해 구버전/신버전 간의 호환이 원활해야 이러한 MSA 구조가 가능하고, 이것이 이번장의 핵심이다

### 웹 서비스
- 서비스와 통신하기 위한 기본 프로토콜로 HTTP를 사용하면 웹 서비스라 부른다
- 대중적인 방법으로 REST와 SOAP가 있다
    - 대략 제가 학교 다니던 시절이후에 SOAP를 접해본적은 없는데 여러분들은 어떠신지?
- REST 원칙에 따라 설계된 API를 RESTful 이라고 부른다
- SOAP는 XML 기반 프로토콜이고 HTTP와 독립적이며 HTTP의 기능을 사용하지 않는 대신 광범위하고 복잡한 여러 표준을 제공한다
    - 책에서는 이게 가장 대중적으로 사용된다고 하는데 찾아보니 금융권을 비롯한 아주 오래된 회사들에서나 써먹는다고 한다..
- RESTful API는 간단한 접근 방식을 선호하고 스웨거와 같은 오픈API를 통해 제품 문서를 기술하는데 사용할 수 있다
    - 우리에겐 🚀api helper 🚀가 있다

## 원격 프로시저 호출 문제(RPC)
- 웹서비스는 1970년대부터 시작한 원격 프로시저 호출(PRC)의 아이디어를 기반으로 한다
- RPC 모델은 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 언어의 함수나 메서드를 호출 하는것과 동일하게 사용하도록 해준다
- 편해보이지만 근본적인 결함이 존재. 네트워크 요청과 로컬 함수 요청은 매우 다르다
- 로컬 함수 호출은 예측 가능하나, 네트워크 요청은 데이터가 유실되거나 장비가 느려지거나 응답하지 않는 문제를 전혀 제어할 수 없다

## RPC의 현재 방향
- 이러한 문제에도 RPC는 사라지지 않는다
- 차세대 RPC 프레임워크는 실패할지도 모르는 비동기 작업을 캡슐화하기 위해 퓨처(promise)를 사용한다
    - 요 주제는 뒤에 '요청 라우팅' 에서 자세히 다룬다
- REST상에 JSON과 같은 프로토콜보다 이진 부호화를 사용하는 RPC 프로토콜이 성능상으로 우수할지 모르나, REST API는 실험과 디버깅에 적합하다
- 또한 다양한 도구 생태계가 있기 때문에 REST는 오픈 API의 주요한 방식으로 보인다
- RPC 프레임워크의 주요 초점은 같은 데이터센터 내의 같은 조직이 소유한 서비스간 요청에 있다

## 메시지 브로커
- 메시지 브로커를 사용하는 방식은 직접 RPC를 사용하는 방식과 비교했을 때 장점이 있다
    - 수신자가 사용 불가능하거나 과부하 상태면 메시지 프로커가 버퍼처럼 동작해서 안정성을 높일 수 있다
    - 죽었던 프로세스에 메시지를 다시 전달할 수 있기 때문에 유실을 방지할 수 있다
    - 송신자가 수신자의 IP 주소나 포트번호를 알 필요가 없다
    - 하나의 메시지를 여러 수신자로 전송할 수 있다
    - 논리적으로 송신자와 수신자와 분리된다
- 메시지 브로커의 상용 소프트웨어는 11장에서 자세히 다룬다

## 분산 액터 프레임워크 
- 액터 모델은 단일 프로세스 안에서 동시성을 위한 프로그래밍 모델이다
- 스레드를 직접 처리하는 대신 로직이 액터에 캡슐화
  - 직접 써보진 않아서 사실 감이 잘 안오긴합니다
- 액터는 비동기 메시지의 송수신으로 다른 액터와 통신하며, 메시지 전달을 보장하지 않고 에러 상황에서 유실될 수 있다
- 각 액터 프로세스는 한번에 하나의 메시지만 처리하기 때문에 스레드에 대하여 걱정할 필요가 없고 프레임워크와 독립적으로 실행 가능
- 액터 모델은 단일 프로세스 안에서도 메시지의 유실을 가정하기 떄문에 위치 투명성은 RPC보다 더 명확하다
- 분산 액터 프레임워크는 기본적으로 메시지 브로커와 액터 프로그래밍 모델을 단일 프레임워크에 통합한다
- 액터 기반 애플리케이션 역시 순회식 업그레이드를 수행한다면 하위 버전 노드 -> 상위 버전 노드로 메시지를 전송할 때 호환성에 주의해야한다
  - 전 직장에서 아카(akka)를 쓰는 팀이 있다는 것 정도만 알고 있었는데, 책에 나와있는 올리언스나 얼랭은 처음봄..

## 정리
- 많은 서비스가 신버전의 서비스를 배포할때 모든 노드에 한번에 배포하는 방식보다 작은 단위로 서서히 배포하는 순회식 업그레이드를 선호한다
- 이는 정지시간 없이 서비스 출시를 가능하게 만들고 결함이 있을 경우 쉽게 롤백을 가능하게 만들기 떄문에 발전성에 많은 도움이 된다
- 순회식 업그레이드를 하거나 다른 여러 이유로 인해 다양한 노드에 다른 버전의 여러 애플리케이션 코드가 수행되는데 이전에 다뤘던 사례들에서 보았듯이 상하위 호환성을 제공하는 것이 중요하다
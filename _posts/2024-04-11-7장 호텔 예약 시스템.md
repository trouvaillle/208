---
layout: post
title:  "7장 호텔 예약 시스템"
date:   2024-04-11 00:00:00 +0900
categories: study books system-design-interview-vol2
announced_on: 2024년 4월 11일
author: hyeonseop choi
---
# 호텔 예약 시스템

- 메리어트 인터내셔널 같은 호텔 체인의 예약시스템 설계하기
- 이 장은 예약이 필요한 서비스 모두에 활용될 수 있음
    - 에어비앤비 시스템 설계
    - 항공권 예약 시스템 설계
    - 영화 티켓 예매 시스템 설계

## **1단계: 문제 이해 및 설계 범위 확정**

1. 시스템 규모 추정
    - 5000개 호텔에 100만개 객실을 갖춘 호텔 체인을 위한 웹사이트
2. 비지니스 추정
    - 결제대금은 예약시 전부 지불
    - 웹사이트에서만 예약 가능 (전화, 이메일 불가능)
    - 예약 취소 가능
    - 10% 초과 예약 가능 (오버부킹)
    - 객실 검색은 제외

### **비기능 요구사항**

- 높은 수준의 동시성 지원: 성수기, 대규모 이벤트 기간에는 일부 인기 호텔의 특정 객실을 예약하려는 고객이 많이 몰릴 수 있음
- 적절한 지연 시간: 사용자가 예약을 할 때는 응답 시간이 빠르면 이상적이겠으나 예약 요청 처리에 몇 초 정도 걸리는 것은 괜찮은것으로 합의

### **계략적 규모 추정**

- 총 5000개의 호텔, 100만개의 객실이 있다고 가정
- 평균적으로 객실의 70%가 사용중이고, 평균 투숙 기간은 3일이라고 가정
- 일일 예상 예약 건수 =>
    
    [https://latex.codecogs.com/svg.image?%5Cfrac%7B1,000,000*3%7D%7B3%7D=233,333](https://latex.codecogs.com/svg.image?%5Cfrac%7B1,000,000*3%7D%7B3%7D=233,333)
    
- 초당 예약 건수 =>
    
    [https://latex.codecogs.com/svg.image?%5Cfrac%7B240,000%7D%7B10%5E%7B5%7D%7D=%5Csim3.](https://latex.codecogs.com/svg.image?%5Cfrac%7B240,000%7D%7B10%5E%7B5%7D%7D=%5Csim3.)
    
- 예상 QPS 계산해보기
    - 최종예약 TPS가 3이라는 것을 알 수 있으므로 그 수치에서 역산해서 QPS를 추정
    - 쓰기(예약)보다 조회가 더 많기 때문에 아래 단계로 구분해서 QPS계산
        1. 호텔/객실 상세 페이지 => QPS 300
        2. 예약 상세 페이지 => QPS 30
        3. 객실 예약 페이지 => QPS 3

## **2단계: 개략적 설계안 제시 및 동의 구하기**

### **API 설계**

`호텔 관련 API`

| API | 설명 |
| --- | --- |
| GET /v1/hotels/:id | 호텔의 상세 정보 반환 |
| POST /v1/hotels | 신규 호텔 추가. 호텔 직원만 사용 가능 |
| PUT /v1/hotels/:id | 호텔 정보 갱신. 호텔 직원만 사용 가능 |
| DELETE /v1/hotels/:id | 호텔 정보 삭제. 호텔 직원만 사용 가능 |

`객실 관련 API`

| API | 설명 |
| --- | --- |
| GET /v1/hotels/:id/rooms/:id | 객실 상세 정보 반환 |
| POST /v1/hotels/:id/rooms | 신규 객실 추가. 호텔 직원만 사용 가능 |
| PUT /v1/hotels/:id/rooms/:id | 객실 정보 갱신. 호텔 직원만 사용 가능 |
| DELETE /v1/hotels/:id/rooms/:id | 객실 정보 삭제. 호텔 직원만 사용 가능 |

`예약 관련 API`

| API | 설명 |
| --- | --- |
| GET /v1/reservations | 로그인 사용자의 예약 이력 반환 |
| GET /v1/reservations/:id | 특정 예약의 상세 정보 반환 |
| POST /v1/reservations | 신규 예약 |
| DELETE /v1/reservations/:id | 예약 취소 |

### **데이터베이스 모델**

`데이터베이스 선택`

- NoSQL보다 RDB가 적합하다고 판단되는 이유
    1. 쓰기보다 읽기가 많다. => RDB는 읽기 빈도가 쓰기 연산에 비해 높은 작업 흐름을 잘 지원한다. 앞서 QPS 추정부분처럼 예약시스템은 조회성향이 높기때문에 RDB가 NoSQL보다 적합하다.
    2. ACID속성. => RDB는 일반적으로 ACID 속성을 보장한다. 예약시스템에서 ACID 속성은 중요하다. (이중 예약, 이중 청구 방지용) ACID속성이 충족되는 데이터베이스를 사용하면 애플리케이션 코드는 훨씬 단순해지고 이해하기 쉬워진다.
    3. 쉬운 모델링. => RDB는 엔티티간의 관계를 명확하게 표현가능하고 안정적으로 지원한다.

`스키마 설계`

![Untitled](/208/assets/img/study/books/system-design-interview-vol2/chapter07/Untitled.png)

- 이 스키마 설계에는 큰 문제가 있는데, 호텔의 경우 객실을 직접 예약하는 것이 아니라 특정 호텔의 **특정 객실 유형**을 예약한다. 그리고 실제 객실의 번호는 예약할때가 아닌 투숙객이 체크인하는 시점에 부여된다.
- 위 요구사항은 3단계 상세설계에서 다시 다룬다.

### **개략적 설계안**

![Untitled](/208/assets/img/study/books/system-design-interview-vol2/chapter07/Untitled%201.png)

`MSA`

- CDN: 이미지, 동영상 등 정적 컨텐츠를 캐시하여 웹사이트 로드 성능을 개선하는데 이용된다.
- 공개 API 게이트웨이: 처리율 제한, 인증 등의 기능을 지원하는 완전 관리형 서비스. 엔드포인트 기반으로 특정 서비스에 요청을 전달할 수 있도록 구성.
- 내부 API: 승인된 호텔 직원만 사용 가능한 API로 내부 소프트웨어나 웹사이트를 통해서 사용 가능. VPN 등의 기술을 사용해 외부 공격으로부터 보호.
- 호텔 서비스: 호텔과 객실에 대한 상세 정보를 제공. 호텔과 객실 데이터는 일반적으로 정적이라서 쉽게 캐시 가능
- 요금 서비스: 미래의 어떤 날에 어떤 요금을 받아야 하는지 데이터를 제공하는 서비스. 객실요금은 해당 날짜에 호텔에 얼마나 많은 손님이 몰리느냐에 따라 달라짐
- 예약 서비스: 예약 요청을 받고 객실을 예약하는 과정을 처리. 객실이 예약되거나 취소될 때 잔여 객실 정보를 갱신하는 역할도 담당.
- 결제 서비스: 고객의 결제를 맡아 처리하고, 절차가 성공적으로 마무리되면 예약 상태를 결제 완료로 갱신하며 실패한 경우에는 승인 실패로 업데이트
- 호텔 관리 서비스: 승인된 호텔 직원만 사용 가능한 서비스. 어드민 기능

`서비스간 연결`

- 실제 사업적으로 이용되는 시스템의 서비스 간 통신에는 gRPC와 같은 고성능 원격 프로시저 호출 프레임워크를 사용하곤 한다.

> grpc
> 
> - google에서 개발한 고성능 원격 프로시저 호출 프레임워크
> - protobuf를 사용해서 클라 - 서버간 통신을 정의하고 데이터를 직렬화함.
> - HTTP2 기반
> - [https://appmaster.io/ko/blog/grpcneun-mueosibnigga](https://appmaster.io/ko/blog/grpcneun-mueosibnigga)

## **3단계: 상세 설계**

### **개선된 데이터 모델**

![Untitled](/208/assets/img/study/books/system-design-interview-vol2/chapter07/Untitled%202.png)

- 간단 설명
    - `room`: 객실에 관련된 정보를 담는다.
    - `room_type_rate`: 특정 객실 유형의 특정 일자 요금 정보를 담는다. (키 매핑이 잘못된듯? `hotel_id`=> `room_type_id`)
    - `reservation`: 투숙객 예약 정보를 담는다.
    - `room_type_inventory`: 호텔의 모든 객실 유형을 담는 테이블.
        - `total_inventory`: 지정된 `hotel_id`, `room_type_id`, `date`에 예약 가능한 객실 수
        - `total_reserved`: 지정된 `hotel_id`, `room_type_id`, `date`에 예약된 모든 객실의 수
- 다르게 설계할 수 있으나 날짜당 하나의 레코드를 사용하면 날짜 범위 내에서 예약을 쉽게 관리하고 질의할 수 있는 장점이 있다.
- 2년이내 모든 가용 객실 데이터를 저장한다고 가정하고 5000 개의 호텔에 각각 20개의 객실 유형이 있다고 가정하면 해당 테이블의 총 레코드 수를 구할 수 있다.
    - 5000 * 20 * 2년 * 365일 = 7300만개

![Untitled](/208/assets/img/study/books/system-design-interview-vol2/chapter07/Untitled%203.png)

- 유스케이스
    1. 주어진 기간에 해당하는 레코드들을 구한다
    
    ```sql
    SELECT date, total_inventory, total_reserved
    FROM room_type_inventory
    WHERE room_type_id = ${roomTypeId} AND hotel_id = ${hotelId}
    AND date between ${startDate} AND ${endDate}
    ```
    
    1. 반환된 레코드를 아래 조건으로 필터링한다
    
    ```
    if ((total_reserved + ${numberOfRoomToReserve}) <= total_inventory)
    ```
    
    1. 요구사항중에 10%의 오버부킹을 적용하면 아래와 같다.
    
    ```
    if ((total_reserved + ${numberOfRoomToReserve}) <= 110% * total_inventory)
    ```
    

### **동시성 문제**

- 이중예약을 어떻게 방지할지도 중요한 문제다.

**1. 같은 사용자가 예약 버튼을 여러번 누를때**

- 클라이언트 측 구현: 클라이언트가 요청을 전송하고 난 다음에 예약버튼을 비활성화하는 방법. 하지만 안정적인 방법은 아님
- 멱등 API로 구현: 예약 API에 멱등 키를 추가하는 방법. (멱등성: 여러번 호출해도 같은 결과를 내는 성질)

![Untitled](/208/assets/img/study/books/system-design-interview-vol2/chapter07/Untitled%204.png)

1. 예약 주문서를 만든다. 고객이 예약 세부 정보를 입력하고 계속 버튼을 누르면 예약 서비스는 예약 주문을 생성한다.
2. 고객이 검토할 수 있도록 예약 주문서를 반환한다. 이때 API는 반환 결과에 `reservation_id`를 넣는다. 이때 `reservation_id`는 전역적 유일성을 보장하는 ID 생성기가 만들어낸 것이어야 한다.
3. 검토가 끝난 예약을 전송한다. 이때 요청에 `reservation_id`가 붙는다. `reservation_id`는 예약 테이블의 pk다.
4. 사용자의 실수, 또는 클라이언트 문제로 같은 예약이 다시 서버로 전송되면 `reservation_id`는 예약 테이블의 pk이기 때문에 유일성 조건이 위반되어 새로운 레코드는 생성되지 않는다. 따라서 동일 사용자의 이중 예약 문제를 피할 수 있다.

**2. 여러 사용자가 같은 객실을 동시에 예약하려할때**

![Untitled](/208/assets/img/study/books/system-design-interview-vol2/chapter07/Untitled%205.png)

- 문제상황
    1. 데이터베이스 트랜잭션 격리 수준이 가장 높은 수준(serializable)이 아닐때 사용자1(트랜잭션1) 과 사용자2(트랜잭션2)는 동시에 예약을 진행하려고한다. 현재 호텔에는 100개의 객실이 있고 그중 99가 예약중이다.
    2. 트랜잭션 1이 먼저 객실을 예약해서 `total_reserved` 값은 100이된다.
    3. 그 직후 트랜잭션 2가 해당 객실을 예약한다. 데이터베이스 ACID 속성중 I(isolation)는 각 트랜잭션은 각 트랜잭션과 무관하게 작업을 완료해야한다. 트랜잭션2에는 트랜잭션1의 결과가 보이지 않기 때문에 트랜잭션2도 예약을 완료한다.
    4. 트랜잭션 1과 트랜잭션 2가 변경 사항을 성공적으로 데이터베이스에 반영한다.
- 위 문제를 해결하려면 어떤 형태로든 락을 활용해야한다.

### 방안 1: 비관적 락

- 비관적 락은 사용자가 레코드를 갱신하려고 하는 순간 즉시 락을 걸어 동시 업데이트를 방지하는 기술
- 해당 레코드를 갱신하려는 다른 사용자는 먼저 락을 건 사용자가 변경을 마치고 락을 해제할때까지 기다려야함.
- MySQL의 `SELECT ... FOR UPDATE` 는 `SELECT`가 반환한 레코드에 락이 걸린다.
- 트랜잭션1에서 `SELECT ... FOR UPDATE` 를 사용했으면 트랜잭션2에서는 트랜잭션1이 커밋될때까지 해당 레코드에 접근할 수 없다.

![Untitled](/208/assets/img/study/books/system-design-interview-vol2/chapter07/Untitled%206.png)

**장점**

- 애플리케이션이 변경 중이거나 변경이 끝난 데이터를 갱신하는 일을 막을 수 있다.
- 구현이 쉽고 모든 갱신 연산을 직렬화하여 충돌을 막는다. 비관적 락은 데이터에 대한 경합이 심할 때 유용하다.

**단점**

- 여러 레코드에 락을 걸면 교착 상태가 발생할 수 있다.
- 확장성이 낮다. 트랜잭션이 너무 오랫동안 락을 해제하지 않으면 성능문제가 발생하기 쉽다.

### 방안 2: 낙관적 락

- 낙관적락은 일반적으로 버전 번호와 타임스탬프의 두가지 방법으로 구현한다. 타임스탬프는 서버간 시간이 부정확해질 수 있으므로 일반적으로 버전 번호를 사용한다.

![Untitled](/208/assets/img/study/books/system-design-interview-vol2/chapter07/Untitled%207.png)

1. 데이터베이스 테이블에 `version` 이라는 필드 추가.
2. 사용자가 데이터베이스 레코드를 수정하기 전에 애플리케이션은 해당 레코드의 버전 번호를 읽는다.
3. 사용자가 레코드를 갱신할 때 애플리케이션은 버전 번호에 1을 더한 다음 데이터베이스에 다시 기록한다.
4. 이때 다음 버전 번호가 현재 버전번호보다 1만큼 큰값이어야 한다. 이 유효성검사가 실패하면 트랜잭션은 중단되고 사용자는 2단계부터 모든 절차를 반복한다.

**장점**

- 데이터베이스 자원에 락을 걸 필요가 없다.
- 데이터에 대한 경쟁이 치열하지 않을때 사용하기 좋다. 이런 상황에서 락을 관리하는 비용 없이 트랜잭션을 실행할 수 있다.

**단점**

- 데이터에 대한 경쟁이 치열한 상황에서는 성능이 좋지 못하다.
- 많은 클라이언트가 같은 호텔 객실을 동시에 예약하는 경우
    - 1000명의 클라이언트가 동시에 같은 버전의 엔티티를 조회한경우 예약을 시도할때 오로지 1명의 사용자만 예약에 성공하고 나머지 999명의 사용자는 예약에 실패해서 다시 예약을 시도해야한다.
    - 최종 결과는 정확하겠지만 반복되는 재시도때문에 사용자는 불쾌한 경험을 가질 수 있다.

### 방안 3: 데이터베이스 제약 조건

![Untitled](/208/assets/img/study/books/system-design-interview-vol2/chapter07/Untitled%208.png)

- `room_type_inventory` 테이블에 아래와 같은 제약조건을 추가한다.

```
CONSTRAINT `check_room_count` CHECK((`total_inventory - total_reserved` >= 0))
```

- 이 조건을 위반하는 트랜잭션은 중단된다.

**장점**

- 구현이 쉽다.
- 데이터에 대한 경쟁이 심하지 않을 때 잘 동작한다.

**단점**

- 낙관적락과 마찬가지로 데이터에 대한 경쟁이 심하면 실패하는 연산수가 엄청나게 늘어날 수 있다.
- 데이터베이스 제약 조건은 애플리케이션 코드와 달라서 버전을 통제하기 어렵다.
- 제약조건을 허용하지 않는 데이터베이스에서는 불가능하다.

### **시스템 규모 확장**

- 일반적으로 호텔 예약 시스템에 부하는 높지 않지만. 면접자가 booking.com, expedia.com 같은 유명한 여행 웹사이트와 연동되어야한다면 어떨까? 라는 질문을 할 수 있다.
- **시스템 부하가 높을때는 무엇이 병목이 될 수 있을지 이해해야한다.**
- 본 시스템의 모든 서비스는 무상태 서비스이므로 서버를 추가하는 것으로 성능 문제는 해결 가능하지만 데이터베이스는 단순히 데이터베이스 서버를 늘리는 것만으로는 성능 문제를 해결하기 어렵다.

### 데이터베이스 샤딩

- 데이터베이스를 여러 대 두고 각각에 데이터의 일부만 보관하도록 하는 기본적인 아이디어.
- 이 시스템의 대부분 질의는 `hotel_id`를 필터링 조건으로 사용하므로 `hotel_id`는 좋은 샤딩키 후보가 된다.

![Untitled](/208/assets/img/study/books/system-design-interview-vol2/chapter07/Untitled%209.png)

### 캐시

![Untitled](/208/assets/img/study/books/system-design-interview-vol2/chapter07/Untitled%2010.png)

- 호텔 잔여 객실은 현재, 미래의 데이터만 중요하고 과거의 데이터는 중요하지 않다.
- 따라서 데이터를 보관할 때 낡은 데이터는 자동적으로 소멸되도록 TTL을 설정할 수 있다면 바람직하다.
- 레디스는 TTL과 LRU캐시 정책을 사용해서 메모리를 최적화하기 때문에 이런 상황에서 사용하기 적합하다.
- 데이터베이스 확장성이 문제가 되기 시작하면 데이터베이스 앞에 캐시 계층을 두고 잔여 객실 확인 및 객실 예약 로직이 해당 층에서 실행되도록 할 수 있다.

`캐시가 주는 새로운 과제`

- 캐시 계층을 추가하면 시스템의 확장성과 처리량은 대폭 증가하지만 데이터베이스와 캐시 사이의 일관성 유지에 관한 문제가 발생한다.
- 일관성을 유지하는 방법
    1. 비동기적 갱신 작업을 애플리케이션에서 수행한다. 데이터베이스에 데이터를 저장했으면 캐시까지 데이터를 수정한다.
    2. 변경 데이터 감지(Change Data Capture) 라는 메커니즘을 사용하는 방법. CDC는 데이터베이스에서 발생한 변화를 감지하여 해당 변경 내역을 다른 시스템에 적용할 수 있는 메커니즘이다. 보편적으로 드베지움(Debezium)을 많이 사용한다. 데이터베이스에서 발생한 변경 내역을 읽는 소스커넥터가 데이터베이스 변화를 감지하여 레디스같은 캐시 시스템에 반영하도록 하는 방안이다.

> Debezium
> 
> - Kafka connect 기반의 오픈소스 플러그인
> - 데이터베이스의 변경 로그를 캡처하여 다른 시스템으로 스트리밍
> - [https://debezium.io/documentation/reference/stable/index.html](https://debezium.io/documentation/reference/stable/index.html)

**장점**

- 읽기 질의를 캐시가 처리하므로 데이터베이스의 부하가 크게 줄어든다.
- 읽기 질의를 메모리에서 실행하므로 높은 성능을 보장할 수 있다.

**단점**

- 데이터베이스와 캐시 사이의 데이터 일관성을 유지하기 어렵다.
- 데이터 불일치가 사용자 경험에 어떤 영향을 끼치게 될지 신중하게 따져봐야한다.

### 서비스 간 데이터 일관성

- 전통적인 모노리스 아키텍처의 경우 데이터의 일관성을 보장하기 위해 관계형 데이터베이스를 공유하는것이 보통이다.
- 이 설계안은 예약 테이블과 잔여 객실 테이블을 동일한 관계형 데이터베이스에 저장하는 하이브리드 접근법을 선택했다. 그러나 면접관이 마이크로서비스 순수주의자라면 이 하이브리드 접근법에 의의를 제기할 가능성이 있다. 마이크로서비스 아키텍처라면 각 마이크로서비스가 독자적인 데이터베이스를 갖추고 있어야 하는 것으로 생각하고 있을 수 있기 때문이다.
- 이런 교조주의적 접근은 다양한 데이터 일관성 문제를 낳는다.
- 단일 데이터베이스를 사용할 때는 여러 연산을 하나의 트랜잭션으로 묶어서 ACID 속성을 잘 활용하여 데이터 일관성을 유지할 수 있지만 여러 데이터베이스를 사용할때는 하나의 트랜잭션으로 데이터 일관성을 보장하는 기법을 사용할 수 없다.
- 이런 데이터 일관성 문제를 해결하기 위한 방법
    - 2단계 커밋
        - 여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 데이터베이스 프로토콜이다.
        - 모든노드가 성공하든 아니면 실패하든 둘 중 하나로 트랜잭션이 마무리되도록 보증하는 것.
        - 2PC는 비중단 실행이 가능한 프로토콜이 아니기 때문에 어느 한 노드에 장애가 발생하면 해당 장애가 복구될때까지 진행이 중단된다.
        - 성능이 좋은 프로토콜은 아니다.
        - [https://velog.io/@jungbumwoo/Two-Phase-commit-%EC%9D%B4%EB%9E%80-2PC](https://velog.io/@jungbumwoo/Two-Phase-commit-%EC%9D%B4%EB%9E%80-2PC)
    - Saga 패턴
        - 각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮은 것.
        - 각각의 트랜잭션은 완료되면 다음 트랜잭션을 시작하는 트리거로 쓰일 메시지들을 만들어 보낸다.
        - 어느 한 트랜잭션이라도 실패하면 그 이전 트랜잭션의 결과를 전부 되돌리는 트랜잭션을 순차적으로 실행한다.
        - 2PC는 여러 노드에 걸친 하나의 트랜잭션을 통해 분산 ACID 속성을 만족시키는 개념이지만 SAGA는 각 단계가 하나의 트랜잭션이라서 결과적 일관성에 의존하는 것으로 보아야 한다.
        - [https://medium.com/cloud-native-daily/microservices-patterns-part-04-saga-pattern-a7f85d8d4aa3](https://medium.com/cloud-native-daily/microservices-patterns-part-04-saga-pattern-a7f85d8d4aa3)
- 마이크로서비스간의 데이터 불일치를 해결하기 위해 사용되는 복잡한 매커니즘은 시스템 전체 설계의 복잡성을 크게 증가시킨다. **증가한 복잡성이 그만한 가치가 있는지 결정하는 것은 설계자의 몫이다.**

## **4단계: 마무리**

- 호텔 예약 시스템의 설계안
    - 요구사항 수집, 규모를 파악하기 위한 추정치 계산.
    - 개략적인 설계안으로 API, 데이터모델, 시스템 아키텍처 다이어그램 제시
    - 동시성 시나리오 체크
    - 데이터베이스 샤딩, 레디스 캐시 등 시스템 규모 확장을 위한 전략
    - 마이크로 서비스 아키텍처에서 발생할 수 있는 데이터 일관성 문제
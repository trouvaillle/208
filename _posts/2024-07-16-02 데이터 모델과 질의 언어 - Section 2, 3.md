---
layout: post
title:  "02.  데이터 모델과 질의 언어 - Section 2, 3"
date:   2024-07-16 00:00:00 +0900
categories: study books data-intensive-applications
---
발표자: 홍성민
발표일: July 16, 2024

# 데이터를 위한 질의 언어

SQL은 **선언형 질의 언어**를 사용해 데이터베이스에 질의한다.

![Untitled](/208/assets/img/study/books/data-intensive-applications/chapter02/section2-3/72a0cf26-e984-4514-a967-b5a06a8c7b69.png)

반면 IMS와 코다실은 **명령형 코드(레코드를 순회하면서 찾기.. 보통 코볼을 사용함)**를 사용해 데이터베이스에 질의한다. 

![Untitled](/208/assets/img/study/books/data-intensive-applications/chapter02/section2-3/Untitled.png)

![Untitled](/208/assets/img/study/books/data-intensive-applications/chapter02/section2-3/Untitled%201.png)

 명령형 언어는 특정 순서로 특정 연산을 수행하게끔 컴퓨터에 지시한다. 선언형 질의 언어에서는 알고자 하는 데이터의 패턴, 즉 결과가 충족해야 하는 조건과 데이터를 어떻게 변환(정렬, 그룹화, 집계)할지를 지정하기만 하면 된다. 어떤 색인과 어떤 조인 함수를 사용할지, 질의의 다양한 부분을 어떤 순서로 실행할지를 결정하는 일은 데이터베이스 **시스템의 질의 최적화기**가 할 일이다.

 SQL이 기능적으로 더 제한적이라는 사실은 데이터베이스에게 자동으로 최적화할 수 있는 여지를 더 많이 준다는 의미다. 

 명령형 코드는 명령어를 특정 순서로 수행하게끔 지정하기 때문에 다중 코어나 다중 장비에서 병렬 처리가 매우 어렵다. 선언형 언어는 종종 병렬 실행에 적합하다.

## 웹에서의 선언형 질의

 선언형 질의 언어의 장점은 데이터베이스에만 국한되지 않는다. 웹 브라우저에서 선언형 CSS 스타일을 사용하는 편이 자바스크립트에서 명령형으로 스타일을 다루기보다 훨씬 낫다. 마찬가지로 데이터베이스에서는 SQL 같은 선언형 질의 언어가 명령형 질의 API보다 훨씬 좋다.

![CSS](/208/assets/img/study/books/data-intensive-applications/chapter02/section2-3/Untitled%202.png)

CSS

![js](/208/assets/img/study/books/data-intensive-applications/chapter02/section2-3/Untitled%203.png)

js

## 맵리듀스(MapReduce) 질의

맵리듀스는 많은 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델이다. 많은 문서를 대상으로 읽기 전용 질의를 수행할 때 사용한다.

맵리듀스는 선언형 질의 언어도 완전한 명령형 질의 API도 아닌 그 중간 정도에 있다. 

예를 들어 해양 생물학자가 되어 바다에서 동물을 볼 때마다 데이터베이스에 관찰 기록을 추가한다고 해보자. 지금부터 한 달에 얼마나 자주 상어를 발견하는지 보고서를 작성하려고 한다.

몽고디비 맵리듀스 기능을 이용해 다음과 같이 표현할 수 있다.

```jsx
db.observations.mapReduce( 
	function map() { #2
		var year = this.observationTimestamp.getFullYear();
	  var month = this.observationTimestamp.getMonth() + 1;
	  emit(year + "-" + month, this.numAnimals); #3
	},
	function reduce(key, values) { #4
		return Array.sum(values); #5
	},
	{
		query: { family: "Sharks"}, #1
		out: "monthlySharkReport" #6
	}
);
```

#1: 상어 종만 거르기 위한 필터를 선언적으로 지정한다.

#2: 모든 문서에 대해 한 번씩 호출되며 this는 문서 객체로 설정된다.

#3: map 함수는 키로 {연}_{월}을 , 값으로 {동물관측 수}를 방출한다.

#4: map이 방출한 키로 그룹화된다. 같은 키를  갖는 모든 쌍은 reduce함수를 한 번 호출한다. 

#5: 특정 월의 모든 관측치에서 동물 수를 합친다.

#6: 최종 출력은 monthlySharkReport 컬렉션에 기록한다.

몽고DB의 map과 reduce 함수는 수행할 때 약간 제약 사항이 있다. 두 함수는 순수함수여야 한다. 즉 입력으로 전달된 데이터만 사용하고 추가적인 데이터베이스 질의를 수행할 수 없어야 하며 side effect가 없어야 한다. 이런 제약 사항 때문에 데이터베이스가 임의 순서로 어디서나 이 함수를 실행할 수 있고 장애가 발생해도 함수를 재실행할 수 있다. 

선언형 언어는 질의 최적화기가 질의 성능을 높일 수 있는 기회를 제공한다. 이런 이유로 몽고DB 2.2는 집계 파이프라인이라 부르는 선언형 질의 언어 지원을 추가했다.

```jsx

db.observations.aggregate([
	{ $match: { family: “Sharks“ }},
	{ $group: {
			_id: {
				year: {$year: "$observationTimestamp"},
				month : { $month : "$observationTimestamp" }
			},
			totalAnimals: { $sum: “$numAnimals" } 
		}
	}
]);
```

# 그래프형 데이터 모델

앞에서 다대다 관계가 다양한 데이터 모델을 구별하는 중요한 기능임을 살펴봤다. 애플리케이션이 주로 일대다 관계(트리 구조 데이터) 이거나 레코드 간 관계가 없다면 문서 모델이 적합하다.

다대다 관계가 매우 일반적이라면 어떨까? 관계형 모델은 단순한 다대다 관계를 다룰 수 있지만 데이터 간 연결이 더 복잡해지면 그래프로 데이터를 모델링하기 시작하는 편이 더 자연스럽다.

![N:M 다대다 관계 - 학생입장에서 여러 학원을 다닐 수 있고 학원입장에서는 여러 학생이 학원을 다닐 수 있다.](/208/assets/img/study/books/data-intensive-applications/chapter02/section2-3/Untitled%204.png)

N:M 다대다 관계 - 학생입장에서 여러 학원을 다닐 수 있고 학원입장에서는 여러 학생이 학원을 다닐 수 있다.

그래프는 두 유형의 객체로 이뤄진다. 정점(vertex)(노드나 엔티티라고도 한다)과 간선(edge)(관계나 호라고도 한다)이다. 많은 유형의 데이터를 그래프로 모델링할 수 있다. 일반적인 예는 다음과 같다.

**소셜 그래프**

정점은 사람이고 간선은 사람들이 서로 알고 있음을 나타낸다.

**웹 그래프**

정점은 웹 페이지고 간선은 다른 페이지에 대한 HTML링크를 나타낸다.

**도로나 철도 네트워크**

정점은 교차로이고 간선은 교차로 간 도로나 철로 선을 나타낸다.

이 같은 그래프 상에서 동작하는 잘 알려진 여러 알고리즘이 있다. 예를 들어 자동차 내비게이션 시스템은 도로 네트워크에서 두 지점 간 최단 경로를 검색하고 페이지랭크는 웹 그래프를 사용해 웹 페이지의 인기와 검색 결과에서 순위를 결정할 수 있다.

## 속성 그래프

속성 그래프 모델에서 각 정점은 다음과 같은 요소로 구성된다.

- 고유한 식별자
- 유출(outgoing) 간선 집합
- 유입(incoming) 간선 집합
- 속성 컬렉션(키-값 쌍)

각 간선은 다음과 같은 요소로 구성된다.

- 고유한 식별자
- 간선이 시작하는 장점(꼬리 정점)
- 간선이 끝나는 정점(머리 정점)
- 두 정점 간 관계 유형을 설명하는 레이블
- 속성 컬렉션(키-값 쌍)

예제 2-2와 같이 두 개의 관계형 테이블(하나는 정점이고 하나는 간선)로 구성된 그래프 저장소를 생각해보자. 예제 2-2의 스키마는 각 정점이나 간선 속성 저장을 위해 포스트그레스큐엘 json 데이터타입을 사용했다. 머리와 꼬리 정점은 각 간선마다 저장된다. 정점을 위한 유입 간선과 유출 간선의 집합이 필요하다면 edges 테이블에 head_vertex나 tail_vertex로 각각 질의할 수 있다.

![Untitled](/208/assets/img/study/books/data-intensive-applications/chapter02/section2-3/Untitled%205.png)

이 모델의 몇 가지 중요한 면은 다음과 같다.

1. 정점은 다른 정점과 간선으로 연결된다. 특정 유형과 관련 여부를 제한하는 스키마는 없다.
2. 정점이 주어지면 정점의 유입과 유출 간선을 효율적으로 찾을 수 있고 그래프를 순회할 수 있다. 즉 일련의 정점을 따라 앞뒤 방향으로 순회한다(예제 2-2에서 tail_vertex와 head_vertex 칼럼에 대해 색인을 생성하는 이유다).
3. 다른 유형의 관계에 서로 다른 레이블을 사용하면 단일 그래프에 다른 유형의 정보를 저장하면서도 데이터 모델을 깔끔하게 유지할 수 있다.

![Untitled](/208/assets/img/study/books/data-intensive-applications/chapter02/section2-3/Untitled%206.png)

그림 2-5에서 볼 수 있듯이 이런 기능을 통해 그래프는 데이터 모델링을 위한 많은 유연성을 제공한다. 그림 2-5는 전통적인 관계형 스키마에서 표현하기 어려운 사례 몇 가지를 보여준다. 예를 들어 국가마다 지역 구조가 다르다. (프랑스에서는 주와 도인 반면 미국에서는 군과 주다). 국가 안의 국가처럼 역사의 굴곡(독립된 주와 국가의 복잡성을 무시)이 있는 경우도 있고 데이터 입도(루시의 현재 거주지는 도시로 명시돼 있지만 출생지는 주 수준으로만 명시됨)가 가지각색이다.

루시와 알랭 또는 그 밖의 사람에 대한 다른 여러 사실을 포함시키기 위해 그래프를 확장한다고 생각해 보자. 예를 들어 그들이 가진 음식 알레르기를 나타내고 어떤 음식에 어떤 물질이 포함됐는지 보여주는 정점 집합과 알레르겐을 연결할 때 사용할 수 있다. 그러면 각 사람들이 먹을 수 있는 안전한 음식이 무엇인지 알아내는 질의 작성이 가능하다. 그래프는 발전성이 좋아서 애플리케이션에 기능을 추가하는 경우 애플리케이션의 데이터 구조 변경을 수용하게끔 그래프를 쉽게 확장할 수 있다.

## 사이퍼 질의 언어

사이퍼는 속성 그래프를 위한 선언형 질의 언어로, 네오포제이 그래프 데이터베이스용으로 만들어졌다. 

예제 2-3은 그림 2-5의 왼쪽 부분을 그래프 데이터베이스로 삽입하는 사이퍼 질의를 보여준다. 나머지 그래프도 비슷하게 추가할 수 있지만 가독성을 위해 생략했다. 각 정점에는 USA나 아이다호 같은 상징적인 이름이 지정돼 있다. 질의의 다른 부분에서 이 이름을 사용해 정점간 간선을 화살표 표기를 사용해 만들 수 있다. 즉 (idaho) -[:WITHIN]→ (USA)의 경우 꼬리 노드는 idaho, 머리 노드는 USA인 WITHIN 레이블의 간선이 된다.

![Untitled](/208/assets/img/study/books/data-intensive-applications/chapter02/section2-3/Untitled%207.png)

![Untitled](/208/assets/img/study/books/data-intensive-applications/chapter02/section2-3/09be5cda-d2d0-4694-aed8-ddac8a09abe7.png)

그림 2-5의 모든 정점과 간선을 데이터베이스에 추가하면 흥미로운 질문 하나를 던질 수 있다. 예를 들어 미국에서 유럽으로 이민 온 모든 사람들의 이름 찾기 같은 질문이다. 더 정확하게 말하면 미국 내 위치의 BORN_IN 간선을 가진 정점과 유럽 내 위치의 LIVING_IN 간선을 갖는 모든 정점을 찾아서 이 정점들의 name 속성을 반환하는 문제다.

예제 2-4는 사이퍼에서 해당 질의를 어떻게 표현하는지 보여준다. MATCH 문에서는 같은 화살표 표기를 이용해 그래프에서 패턴을 찾는다. (person) -[:BORN_IN] → () 는 BORN_IN 레이블을 가진 간선과 관련된 두 정점을 찾는다. 이 간선의 꼬리 정점은 person 변수에 묶여 있고 머리 정점은 명기하지 않은 채로 남아 있다.

![Untitled](/208/assets/img/study/books/data-intensive-applications/chapter02/section2-3/Untitled%208.png)

질의는 다음과 같이 읽힌다.

다음 두 가지 조건을 만족하는 정점(person이라 부름)을 찾아라.

1. person은 어떤 정점을 향하는 BORN_IN 유출 간선을 가진다. 이 정점에서 name 속성이 “United States”인 Location유형의 정점에 도달할 때까지 일련의 WITHIN 유출 간선을 따라간다.
2. 같은 person 정점은 LIVES_IN 유출 간선도 가진다. 이 간선과 WITHIN 유출 간선을 따라가면 결국 name 속성이 “Europe”인 Location 유형의 정점에 도달하게 된다.

각 person 정점마다 name 속성을 반환한다.

보통 선언형 질의 언어는 질의를 작성할 때 이처럼 수행에 대해 자세히 지정할 필요가 없다. 질의 최적화기가 가장 효율적이라고 예측한 전략을 자동으로 선택하므로 작성자는 나머지 애플리케이션만 작성하면 된다.

## SQL의 그래프 질의

예제 2-2는 관계형 데이터베이스에서 그래프 데이터를 표현할 수 있음을 제안했다. 그렇다면 그래프 데이터를 관계형 구조로 넣어도 SQL을 사용해 질의할 수 있을까?

대답은 ‘예’지만 약간 어렵다. 관계형 데이터베이스에서는 대개 질의에 필요한 조인을 미리 알고 있다. 그래프 질의에서는 찾고자 하는 정점을 찾기 전에 가변적인 여러 간선을 순회해야 한다. 즉 미리 조인 수를 고정할 수 없다.

예제에서 간선 순회는 사이퍼 질의의 () - [:WITHIN*0..] → () 문에서 발생한다. person의 LIVES_IN 간선은 위치 유형(거리, 도시, 지구, 군, 주 등)을 가리킨다. 도시는 군으로, 군은 주로, 주는 국가와 WITHIN 간선으로 이어진다. LIVES_IN 간선은 찾고자 하는 위치 정점을 직접 가리킬 수 있으나 위치 계층 구조에서 제거된 일부 수준일 수도 있다.

사이퍼에서 WITHIN*0..는 이 사실을 간결하게 표현한다. 이는 “0회 이상 WITHIN 간선을 따라가라”는 의미다. 정규 표현식의 * 연산자와 같다.

## 트리플 저장소와 스파클

트리플 저장소 모델은 속성 그래프 모델과 거의 동등하다. 이 모델은 같은 생각을 다른 용어를 사용해 설명한다. 그럼에도 애플리케이션 구축에 유용한 도구일지도 모를 트리플 저장소를 위한 다양한 도구와 언어가 있기 때문에 논의할 만한 가치가 있다.

트리플 저장소에서는 모든 정보를 주어 서술어 목적어 처럼 매우 간단한 세 부분 구문 형식으로 저장한다. 예를 들어 (짐, 좋아하다, 바나나) 트리플에서 짐은 주어, 좋아하다는 서술어, 바나나는 목적어다.

트리플의 주어는 그래프의 정점과 동등하다. 목적어는 두 가지 중 하나다.

1. 문자열이나 숫자 같은 원시 데이터타입의 값, 이 경우 트리플의 서술어와 목적어는 주어 정점에서 속성의 키, 값과 동등하다. 예를 들어 (루시, 나이, 33)은 {”age”: 33} 속성을 가진 정점 lucy와 같다.
2. 그래프의 다른 정점, 이 경우 서술어는 그래프의 간선이고 주어진 꼬리 정점이며 목적어는 머리 정점이다. 예를 들어 (루시, 결혼하다, 알랭)에서 주어와 목적어인 루시와 알랭은 모두 정점이고 서술어 결혼하다는 두 정점을 잇는 간선의 레이블이다.

## 스파클 질의 언어

스파클은 RDF 데이터 모델을 사용한 트리플 저장소 질의 언어다. 스파클은 사이퍼보다 먼저 만들었고 사이퍼의 패턴 매칭을 스파클에서 차용했기 때문에 이 둘은 매우 유사해 보인다.

![Untitled](/208/assets/img/study/books/data-intensive-applications/chapter02/section2-3/Untitled%209.png)

구조는 매우 유사하며 다음 두 표현식은 동등하다(스파클에서 변수는 물음표로 시작한다).

![Untitled](/208/assets/img/study/books/data-intensive-applications/chapter02/section2-3/Untitled%2010.png)

## 정리

역사적으로 데이터를 하나의 큰 트리(계층 모델)로 표현하려고 노력했지만 다대다 관계를 표현하기에는 트리 구조가 적절하지 않았다. 이 문제를 해결하기 위해 관계형 모델이 고안됐다. 최근 개발자들은 관계형 모델에도 적합하지 않은 애플리케이션이 있다는 사실을 발견했다. 새롭게 등장한 비관계형 데이터저장소인 “NoSQL”은 다음과 같은 두 가지 주요 갈래가 있다.

1. 문서 데이터베이스는 데이터가 문서 자체에 포함돼 있으면서 하나의 문서와 다른 문서 간 관계가 거의 없는 사용 사례를 대상으로 한다.
2. 그래프 데이터베이스는 문서 데이터베이스와는 정반대로 모든 것이 잠재적으로 관련 있다는 사용 사례를 대상으로 한다.

세 가지 모델 (문서, 관계형, 그래프) 모두 현재 널리 사용하고 있으며 각 모델은 각자의 영역에서 훌륭하다. 한 모델을 다른 모델로 흉내 낼 수 있지만(예를 들어 그래프 데이터는 관계형 데이터베이스로 표현할 수 있다) 그 결과는 대부분 엉망이다. 이것이 바로 단일 만능 솔루션이 아닌 각기 목적에 맞는 다양한 시스템을 보유해야 하는 이유다.

![Untitled](/208/assets/img/study/books/data-intensive-applications/chapter02/section2-3/Untitled%2011.png)
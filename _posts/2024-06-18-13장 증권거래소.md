---
layout: post
title:  "13장 증권거래소"
date:   2024-06-18 00:00:00 +0900
categories: study books system-design-interview-vol2
---
발표일: 2024년 6월 18일
발표자: 홍성민

# 1단계: 문제 이해 및 설계 범위 확정

## 기능 요구사항

- 종목
    - 주식
- 주문
    - 새 주문 기능
    - 체결되지 않은 주문 취소 기능
    - 지정가 주문
    - 하루에 수십억 건의 주문이 발생할 수 있음
- 알림
    - 주문이 체결된 경우 실시간으로 그 사실을 알 수 있어야함
- 호가 창
    - 호가 창의 정보는 실시간으로 갱신
    - 호가 창은 매수 및 매도 주문 목록이 표시되는 곳
- 지갑
    - 주문 전에 충분한 자금이 있는지 확인
- 위험성 점검이 가능해야함

## 비기능 요구사항

- 확장성: 최소 100가지 주식 거래가 가능, 최수 수만 명 사용자가 동시에 거래할 수 있어야 함
- 가용성: 최소 99.99% 거래소의 가용성은 매우 중요한 문제다. 단 몇 초의 장애로도 평판이 손상될 수 있다.
- 결함 내성(fault tolerance): 프로덕션 장애의 파급을 줄이려면 결함 내성과 빠른 복구 매커니즘이 필요하다.
- 지연 시간(latency): 왕복 지연 시간(round trip latency)은 밀리초 수준이어야 한다
- 보안(security): 사용자 신원 확인을 위한 KYC 확인 수행. DDoS 공격을 방지하는 장치를 구비해 두어야 한다.

## 개략적 규모 추정

- 100가지 주식
- 하루 10억 건의 주문
- 영업 시간은 6.5시간
- QPS는 43,000(10억 / 6.5시간 * 3600초)
- 최대 QPS: 5 * QPS = 215,000

# 2단계 개략적 설계안 제시 및 동의 구하기

## 브로커

대부분의 개인 고객은 브로커 시스템을 통해 거래소와 거래한다. 로빈후드 하나증권 등이 브로커에 해당한다. 브로커 시스템은 개인 사용자가 증권을 거래하고 시장 데이터를 확인할 수 있도록 편리한 사용자 인터페이스를 제공한다.

## 개략적 설계안

### 거래 흐름(trading flow)

거래흐름을 통해 하나의 주문이 어떤 절차로 처리되는지 살펴보자. 지연 시간 요건이 엄격한, 중요 경로(critical path)다. 

1단계: 고객이 브로커의 웹 또는 모바일 앱을 통해 주문한다.

2단계: 브로커가 주문을 거래소에 전송한다. 

3단계: 주문이 클라이언트 게이트웨이를 통해 거래소로 들어간다. 클라이언트 게이트웨이는 입력 유효성 검사, 속도 제한, 인증, 정규화 등과 같은 기본적인 게이트키핑(gatekeeping) 기능을 수행한다. 그런 다음 주문을 주문 관리자에게 전달한다.

4~5단계: 주문 관리자가 위험 관리자가 설정한 규칙에 따라 위험성 점검을 수행한다.

6단계: 위험성 점검 과정을 통과한 주문에 대해 지갑에 주문 처리 자금이 충분한지 확인한다.

7~9단계: 주문이 체결 엔진으로 전송된다. 체결 가능 주문이 발견되면 체결 엔진은 매수 측과 매도 측에 각각 하나씩 두 개의 집행 기록을 생성한다. 나중에 그 과정을 재생할 때 항상 결정론적으로 동일한 결과가 나오도록 보장하기 위해 시퀀서는 주문 및 집행 기록을 일정 순서로 정렬한다.

10~14단계: 주문 집행 사실을 클라이언트에 전송한다.

[https://www.notion.so](https://www.notion.so)

### 시장 데이터 흐름(market data flow)

시장 데이터 흐름을 따라서, 하나의 주문이 체결 엔진부터 데이터 서비스를 거쳐 브로커로 전달되어 집행되기까지의 과정을 추적해 보자.

M1 단계:체결 엔진은 주문이 체결되면 집행 기록 스트림을 만든다. 이 스트림은 시장 데이터 게시 서비스로 전송된다.

M2 단계: 시장 데이터 게시 서비스는 집행 기록 및 주문 스트림에서 얻은 데이터를 시장 데이터로 사용하여 봉 차트와 호가 창을 구성한다. 그런 다음 시장 데이터를 데이터 서비스로 보낸다.

M3 단계: 시장 데이터는 실시간 분석 전용 스토리지에 저장된다. 브로커는 데이터 서비스를 통해 실시간 시장 데이터를 읽는다. 브로커는 이 시장 데이터를 고객에게 전달한다.

### 보고 흐름(report flow)

R1 ~ R2 단계: 보고 서비스는 주문 및 실행 기록에서 보고에 필요한 모든 필드의 값을 모은 다음 그 값을 종합해 만든 레코드를 데이터베이스에 기록한다.

## 거래 흐름

모든 것은 신속하게 진행되어야 한다. 거래 흐름의 핵심은 체결 엔진이다.

### 체결 엔진

체결 엔진은 교차 엔진이라고도 한다. 체결 엔진의 주요 역할은 다음과 같다.

1. 각 주식 심벌에 대한 주문서 내지 호가 창을 유지 관리한다. 주문서 또는 호가 창은 특정 주식에 대한 매수 및 매도 주문 목록이다.
2. 매수 주문과 매도 주문을 연결한다. 주문 체결 결과로 두개의 집행 기록이 만들어진다. 체결은 빠르고 신속하게 처리되어야 한다.
3. 집행 기록 스트림을 시장 데이터로 배포한다.

입력으로 주어지는 주문 순서가 같으면 체결 엔진이 만드는 집행 기록 순서는 언제나 동일해야 한다. 이러한 결정론적 특성이 고가용성의 토대가 된다.

### 시퀀서

체결 엔진을 결정론적으로 만드는 핵심 구성 요소다. 시퀀서는 체결 엔진에 주문을 전달하기 전에 순서 ID(sequence ID)를 붙여 보낸다. 또한 체결 엔진이 처리를 끝낸 모든 집행 기록 쌍에도 순서 ID를 붙인다. 즉 입력, 출력 시퀀서 두 가지가 있고 각각 고유한 순서를 유지한다. 시퀀서가 만드는 순서 ID는 누락된 항목을 쉽게 발견할 수 있는 일련번호여야 한다.

[https://www.notion.so](https://www.notion.so)

순서 ID를 찍는 이유는 다음과 같다.

1. 시의성(timeliness) 및 공정성(fairness)
2. 빠른 복구(recovery) 및 재생(replay)
3. 정확한 1회 실행 보증(exactly-once guarantee)

시퀀서는 순서 ID만 생성하는 것이 아니며, 메시지 큐 역할도 한다. 

### 주문 관리자

주문관리자는 한쪽에서 주문을 받고 다른쪽에서는 집행 기록을 받는다. 주문 상태를 관리하는 것이 주문 관리자의 역할이다.  실제 거래소 시스템이라면 수만 가지 경우를 처리해야 한다.

### 클라이언트 게이트웨이

문지기다. 클라이언트 주문을 받아 주문 관리자에게 보낸다. 

[https://www.notion.so](https://www.notion.so)

빨리 올바른 목적지로 주문을 전달해야 한다. 복잡한 기능이라면 체결 엔진이나 위험 점검 컴포넌트에 맡겨야 한다.

## 시장 데이터 흐름

시장 데이터 게시 서비스는 체결 엔진에서 집행기록을 수신하고 집행 기록 스트림에서 호가 창과 봉 차트를 만들어 낸다.

[https://www.notion.so](https://www.notion.so)

## 보고 흐름

거래 흐름에서는 짧은 지연 시간이 중요하지만 보고 흐름은 그렇지 않다. 정확성과 규정 준수가 핵심이다.

[https://www.notion.so](https://www.notion.so)

## API 설계

기관용으로 설계하는것이 아니기 때문에 RESTful API로 설계한다.

### 주문

POST /v1/order

이 엔드포인트는 주문을 처리한다. 인증이 필요하다.

### 집행

GET /v1/execution?symbol={:symbol}&orderId={:orderId}&startTime={:startTime}&endTime={:endTime}

이 엔드포인트는 집행 정보를 질의한다. 인증이 필요하다.

### 호가 창/주문서

GET /v1/marketdata/orderBook/L2?symbol={:symbol}&depth={:depth}

이 엔드포인트는 주어진 주식 심벌, 주어진 깊이 값에 대한 L2 호가 창 질의 결과를 반환한다.

### 가격 변동 이력(봉 차트)

GET /v1/marketdata/candles? 생략

주어진 시간 범위, 해상도(1분 봉, 1시간 봉 등), 심벌에 대한 봉 차트 데이터 질의 결과를 반환한다.

### 데이터 모델

증권 거래소에는 세 가지 유형의 주요 데이터가 있다.

- 상품, 주문 및 집행
- 호가 창/주문서
- 봉 차트

### 상품, 주문, 집행

상품은 거래 대상 주식이 가진 속성으로 정의된다. 상품의 유형, 거래에 쓰이는 심벌, UI에 표시될 심벌, 결산에 이용되는 통화 단위, 매매 수량 단위(lot size), 호가 가격 단위(tick size) 등이다. 이 데이터는 자주 변경되지 않는다. 주로 UI 표시를 위한 데이터다. 아무 데이터베이스에나 저장 가능하며, 캐시를 적용하기 좋다.

 주문은 매수 또는 매도를 실행하려는 명령이며, 집행 기록을 체결이 이루어진 결과다.

[https://www.notion.so](https://www.notion.so)

주문과 집행 기록은 거래소가 취급하는 가장 중요한 데이터다.

- 중요 거래 경로는 주문과 집행 기록을 데이터베이스에 저장하지 않는다. 성능을 높이기 위해 메모리에서 거래를 체결하고 하드디스크나 공유 메모리를 활용하여 주문과 집행 기록을 저장하고 공유한다. 특히 주문과 집행 기록은 빠른 복구를 위해 시퀀서에 저장하며, 데이터 보관은 장 마감 후에 실행한다.
- 보고 서비스는 조정이나 세금 보고 등을 위해 데이터베이스에 주문 및 집행 기록을 저장한다.
- 집행 기록은 시장 데이터 프로세서로 전달되어 호가 창/주문서와 봉 차트 데이터 재구성에 쓰인다.

### 호가 창

호가 창은 특정 증권 상품에 대한 매수 및 매도 주문 목록으로, 가격 수준별로 정리되어 있다. 다음 요구사항을 만족할 필요가 있다.

- 일정한 조회 시간
- 빠른 추가/취소/실행 속도: 가급적 O(1) 시간 복잡도를 만족해야 한다. 주문 넣기, 기존 주문 취소하기, 주문 체결하기 등이 있다.
- 빠른 업데이트: 주문 교체 등이 있다.
- 최고 매수 호가/ 최저 매도 호가 질의
- 가격 수준 순회

[https://www.notion.so](https://www.notion.so)

2,700주에 대한 대량 시장가 매수 주문이 처리되는 과정은 이렇다.

100.11 큐의 첫 번째 매도 주문과 체결되며 거래가 끝난다. 체결 결과로 매도 호가는 100.11 매수 호가는 100.08 현재 주식가격은 100.11이 된다.

효율적인 구현을 위해 이중 연결 리스트 자료구조를 사용한다.

1. 새 주문은 PriceLevel 리스트 마지막(tail)에 새 Order를 추가하는 것을 의미한다. 이중 연결 리스트에서 이 연산은 O(1)에 처리된다. 
2. 주문을 체결한다는 것은 PriceLevel 리스트의 맨 앞(head)에 있는 Order를 삭제한다는 것과 같다. 이중 연결 리스트의 경우 이 연산의 시간 복잡도는 O(1)이다.
3. 주문을 취소한다는 것은 호가 창, 즉 OrderBook에서 Order를 삭제한다는 뜻이다. OrderBook에 포함되어 있는 도움 자료구조 Map<OrderId, Order> orderMap을 활용하면 O(1) 시간 내에 취소할 주문을 찾을 수 있다. 이중 연결 리스트를 사용하기 때문에 발견된 Order안에 이전 주문을 가리키는 포인터가 있으므로 전체 주문 목록을 순회하지 않고도 주문을 삭제할 수 있다.

[https://www.notion.so](https://www.notion.so)

### 봉 차트

하나의 봉이 커버하는 시간 범위가 경과하면 다음 주기를 커버할 새 캔들스틱 클래스 객체를 생성하여 캔들스틱차트 객체 내부 연결 리스트에 추가한다.

봉 차트에서 많은 종목의 가격 이력을 다양한 시간 간격을 사용해 추적하려면 메모리가 많이 필요하다.

1. 미리 메모리를 할당해 둔 링(ring) 버퍼에 봉을 보관하면 새 객체 할당 횟수를 줄일 수 있다.
2. 메모리에 두는 봉의 개수를 제한하고 나머지는 디스크에 보관한다.

자세한건 3단계에서 고고.

# 3단계: 상세 설계

## 성능

네트워크 지연시간을 낮추기 위해 단일 서버를 사용. 

[https://www.notion.so](https://www.notion.so)

애플리케이션 루프는 while 순환문을 통해 실행할 작업을 계속 폴링(polling) 한다. 다이러그램의 각 상자는 컴포넌트를 나타낸다. 컴포넌트는 서버의 프로세스이다. CPU 효율성을 극대화하기 위해 애플리케이션 루프는 단일 스레드로 구현하며, 특정 CPU 코어에 고정시킨다. 주문관리자를 예를 들면 아래와 같다.

[https://www.notion.so](https://www.notion.so)

- 컨텍스트 스위치가 없다.
- 상태를 업데이트하는 스레드가 하나뿐이라 락을 사용할 필요가 없다. 잠금 경합도 없다.

이 두가지 모두 P99 지연 시간 경감에 기여한다.

mmap은 프로세스 간 고성능 메모리 공유 매커니즘을 제공한다. 메모리에 매핑할 파일이 /dev/shm에 위치하며 효율성이 더 좋다. 공유 메모리에 접근해도 디스크 I/O는 발생하지 않는다.

이를 사용하면 메시지 전송에 마이크로초 미만이 걸린다.

## 이벤트 소싱

이벤트 아키텍처는 현재 상태를 저장하는 대신 상태를 변경하는 모든 이벤트의 변경 불가능한(immutable) 로그를 유지한다. 이 로그를 절대적 진실의 원천으로 삼는 것이다.

[https://www.notion.so](https://www.notion.so)

[https://www.notion.so](https://www.notion.so)

카프카 처럼 pub/sub 으로 동작한다. mmap이벤트 저장소를 각 컴포넌트에서 sub 한다.

각 이벤트 저장소에는 하나의 시퀀서만 있다.

[https://www.notion.so](https://www.notion.so)

## 고가용성

본 설계안은 99.99%의 가용성을 염두에 두고 설계하였다. 거래소가 다운될 수 있는 시간은 하루에 8.64초를 넘으면 안 된다는 뜻이다. 따라서 서비스가 다운되면 즉각 복구해야 한다.

- 체결 엔진에 발생하는 장애는 거래소에는 재앙이다. 따라서 주 인스턴스를 다중화해야 한다.
- 장애 감지 및 백업 인스턴스로의 장애 조치 결정이 빨라야 한다.

주문 관리자나 체결 엔진처럼 상태를 저장하는 컴포넌트는 사본 간에 상태 데이터를 복사할 수 있어야 한다.

부 체결 엔진은 동일한 이벤트를 수신하고 처리하지만 이벤트 저장소로 이벤트를 전송하지는 않는다. 주 인스턴스가 다운되면 부 인스턴스는 즉시 주 인스턴스 지위를 승계한 후 이벤트를 전송한다. 부 인스턴스가 다운된 경우, 일단 재시작 하고 나서 이벤트 저장소 데이터를  사용해 모든 상태를 복구한다. 이벤트 소싱 아키텍처는 거래소에 적합하다. 그 결정론적(deterministic) 특성 때문에 상태 복구가 쉽고 정확하기 때문이다.

[https://www.notion.so](https://www.notion.so)

주 체결 엔진의 문제를 자동 감지할 매커니즘이 필요하다. 하드웨어와 프로세스를 모니터링하는 일반적인 방안 외에도, 체결 엔진과 박동 메시지를 주고받는 방안도 생각해 볼 수 있다. 박동 메시지를 시간 내에 받지 못하면 체결 엔진에 문제가 있는 것으로 판단하는 것이다.

 이 주/부 체결 엔진 설계안의 문제점은 단일 서버 안에서만 동작한다는 것이다. 고가용성을 달성하려면 이 개념을 여러 서버 또는 데이터 센터 전반으로 확장해야 한다. 주/부 체결 엔진이 아니라 주/부 서버의 클러스터를 구성해야 한다는 뜻이다. 주 서버의 이벤트 저장소는 모든 부 서버로 복제해야 한다. 안정적 UDP를 사용하면 모든 부 서버에 이벤트 메시지를 효과적으로 브로드캐스트 할 수 있다.

## 결함 내성

1. 주 서버가 다운되면 언제 어떻게 부 서버로 자동 전환하는 결정을 내리나?

처음 출시할 때는 수동으로 장애 복구 조치를 수행한다. 충분한 시그널, 운영 경험을 축적하여 시스템에 자신이 생기면 그 때 자동으로 장애를 감지하여 복구하는 프로세스를 도입하는 것이다. 카오스 엔지니어링은 드물게 발생하는 까다로운 사례를 수면으로 이끌어내고 운영 경험을 빠르게 축적하는 데 좋은 방법이다.

1. 부 서버 가운데 새로운 리더는 어떻게 선출하는가?

여러 리더 선출 알고리즘 중 래프트(Raft) 라는 알고리즘을 사용해본다. 그림 13.21은 자체 이벤트 저장소가 있는 5개의 서버가 있는 래프트 클러스터 사례다. 현재 리더는 다른 모든 인스턴스, 즉 팔로워에 데이터를 전송한다. 래프트에서 작업 수행에 필요한 최소 투표수는 n/2 + 1 이며, 여기서 n 은 클러스터의 구성원 수다. 따라서 이 사례의 경우 최소 투표수는 5/2 + 1 =3 이다.

그림 13.21은 팔로워가 RPC를 통해 리더로부터 새 이벤트를 수신하는 과정을 보여 준다. 수신된 이벤트는 팔로워의 자체 mmap 이벤트 저장소에 저장된다.

[https://www.notion.so](https://www.notion.so)

리더 선출 과정을 살펴보자. 리더는 팔로워에게 AppendEntries 호출을 보낸다. 일정 기간 동안 메시지를 받지 못한 팔로워는 새 리더를 선출하는 선거 타이머를 시작한다. 가장 먼저 그 타이머가 타임아웃된 팔로워는 후보가 되고 다른 나머지 팔로워에게 투표를 요청한다. 그 팔로워가 과반수 이상의 표를 받으면 새로운 리더가 된다. 첫 번째 팔로워의 임기(trem) 값이 새 노드보다 짧으면 리더가 될 수 없다. 여러 명의 팔로워가 동시에 후보가 되는 경우는 분할 투표라고 한다. 이 경우 기존 선거의 타임아웃을 선언하고 새로운 선거를 시작한다. 시간 축이 정상 운영 기간과 선거 기간을 나타내는 임의 구간으로 분할되어 있으며, 이 각 구간이 어떤 리더의 임기다.

[https://www.notion.so](https://www.notion.so)

[https://seongjin.me/raft-consensus-algorithm/](https://seongjin.me/raft-consensus-algorithm/)

1. 복구 시간 목표는 얼마인가?

다음으로 복구 시간을 살펴보자. 복구 시간 목표는 애플리케이션이 다운되어도 사업에 심각한 피해가 없는 시간의 최댓값이다. 증권 거래소의 경우 2등급 RTO를 달성해야 하는데 그러려면 서비스의 자동 복구가 반드시 가능해야 한다. 이를 위해 우선순위에 따라 서비스를 분류하고 최소 서비스 수준을 유지하기 위한 성능 저하 전략을 정의한다.

1. 어떤 기능을 복구해야 하는가? 시스템이 성능 저하 상태로도 동작할 수 있는가?

복구 지점 목표는 비즈니스에 심각한 피해가 발생하기 전에 손실될 수 있는 데이터의 양 즉 손실 허용 범위를 의미한다. 실무에서는 데이터는 자주 백업해야 한다는 것과 같은 뜻으로 받아들인다. 증권 거래소는 데이터 손실을 용납할 수 없으므로 RPO가 0에 가깝다. 래프트 매커니즘을 사용하면 데이터 사본은 많다. 모든 클러스터 노드가 같은 상태를 갖도록 보장할 수도 있다. 현재 리더에 장애가 생기면 새로운 리더가 중단 없이 작업을 계속할 수 있다.

## 체결 알고리즘

[https://www.notion.so](https://www.notion.so)

[https://www.notion.so](https://www.notion.so)

이 의사 코드는 FIFO(선입선출) 체결 알고리즘을 사용한다. 

## 결정론

기능적 결정론과 지연 시간 결정론이 있다. 시퀀서나 이벤트 소싱 아키텍처를 도입함으로써 이벤트를 동일한 순서로 재생하면 같은 결과를 얻을 수 있도록 보장했는데 그것이 기능적 결정론이다. 기능적 결정론에서는 이벤트가 발생하는 실제 시간은 대체로 중요하지 않다. 중요한 것은 순서다. 그림 13.23에서는 시간 축 위에 불규칙하게 나열된 타임스탬프들이 연속된 점들로 변환되었는데, 그렇게 되면 재생과 복구에 소요되는 시간이 크게 줄어든다.

[https://www.notion.so](https://www.notion.so)

지연 시간 결정론은 각 거래의 처리 시간이 거의 같다는 뜻이다. 사업에서 가장 중요한 부분이다. 이를 측정하는 수학적인 방법은 99번 백분위수 지연 시간(p99)이나 99.99번 백분위수 지연 시간을 재는 것이다. 지연 시간 계산에는 HdrHistogram을 활용할 수 있다. p99 지연 시간이 낮다는 것은 거래소가 거의 모든 거래에 안정적인 성능을 제공한다는 뜻이다.

자바의 경우 지연 시간 변동 폭이 커지는 대표적인 사례는 JVM의 Stop the World 가비지 컬렉트 알고리즘이다. 

# 4단계: 마무리

이 장을 읽고나면 대형 거래소를 위한 이상적인 배포 모델은 모든 것을 하나의 거대한 서버 또는 단일 프로세스에 배치하는 것이라는 결론에 도달할 것이다. 실제로 일부 거래소는 이런 방식을 따른다.

최근 암호화폐 산업이 발전함에 따라 많은 암호화폐 거래소가 클라우드 인프라를 사용하여 서비스를 배포한다.

클라우드 생태계가 제공하는 편리함은 설계의 방향을 바꾸었을 뿐 아니라 업계 진입 문턱도 낮추고 있다. 이런 흐름은 금융업에 혁신적인 에너지를 불어 넣을 것이다. 

두나무, 카카오뱅크, 토스증권, 토스뱅크로도 가보시죠!
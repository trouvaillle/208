---
layout: post
title:  "11장. 결제 시스템"
date:   2024-05-27 00:00:00 +0900
categories: study books system-design-interview-vol2
announced_on: 2024년 5월 27일
author: 전현우
---
### 결제 시스템이란?

- 금전적 가치의 이전을 통해 금융 거래를 정산하는 데 사용되는 모든 시스템

### 1단계: 문제 이해 및 설계 범위 확정

- 기능 요구사항
    - 대금 수신 흐름: 판매자 대신 고객에게 대금 수령
    - 대금 정산 흐름: 판매자에게 제품 판매 대금 송금
- 비기능 요구사항
    - 신뢰성 및 내결함성: 결제 실패는 신중하게 처리
    - 내부 서비스와 외부 서비스 간의 조정 프로세스: 결제 정보 일치 확인
- 개략적인 규모 추정
    - 하루에 100만건의 트랜잭션을 처리해야 하는데 이는 초당 10건의 트랜잭션(10TPS) 이며
    10TPS는 일반적으로 DB로 별 문제 없이 처리가 가능하므로, 처리 대역폭보다는 결제 트랜잭션의 정확한 처리에 초점을 맞춰야 함.

### 2단계: 개략적 설계안 제시 및 동의 구하기

- 대금 수신 흐름

![KakaoTalk_20240528_145102295.jpg]({{ "/assets/img/study/books/system-design-interview-vol2/chapter11/KakaoTalk_20240528_145102295.jpg" | relative_url }})

![KakaoTalk_20240528_145728585.jpg]({{ "/assets/img/study/books/system-design-interview-vol2/chapter11/KakaoTalk_20240528_145728585.jpg" | relative_url }})

- 결제 서비스
    - 사용자로부터 결제 이벤트를 수락 및 결제 프로세스 조율
    - AML/CFI - 자금세탁방지(AML·Anti-Money Laundering)과 테러자금조달방지(CFT·Combating the Financing of Terrorism) 규정 준수 확인
    - 위의 과정을 통과한 결제만 처리함
    - 일반적으로 위험 확인 서비스는 매우 복잡하고 고도화되어 있어서 제3의 제공업체를 이용함
        - 네이버페이는 AML 부서가 따로 있는거같긴 함
- 결제 실행자
    - 결제 서비스 공급자(PSP) ex.paypal 을 통해 하나의 결제 주문을 실행. 
    1 결제 이벤트: N 결제 주문 개념
- 결제 서비스 공급자
    - A계정에서 B 계정으로 돈을 옮기는 역할
- 카드 유형
    - 비자, 마스터카드 등
- 원장
    - 결제 트랜잭션에 대한 금융 기록. 인출, 지급에 대한 모든 것
    - 원장 시스템을 통해 총 수익 계산 및 분석을 통한 예측까지 가능
- 지갑
    - 판매자의 계정 잔액을 기록한다
- 결제 서비스 API
    - `POST /v1/payments`
        - 결제 이벤트 실행 API이며 여기서 짚고 넘어갈만한 것은 잔액(amount) 필드의 자료형을 String으로 처리 한것이다
        - Double을 사용하지 않는 이유
            - 직렬화/역직렬화를 할때 여러 환경에 따라 숫자 정밀도가 달라서 의도치 않은 반올림 등이 발생 가능함
            - 숫자가 매우 클수도, 작을수도 있어서 표기 오류 발생 여지가 있음
    - `GET /v1/payments/{:id}`
        - 단일 결제 주문의 실행상태 조회
- 결제 서비스 데이터 모델
    - 결제 시스템에서 일반적으로 성능은 가장 중요한 고려 사항이 아니고 더욱 중요한 것은 아래와 같다
        - 안전성이 검증 되었는가
        - 모니터링 도구가 풍부하게 지원되는가
        - DBA 채용시장이 성숙해 있는가
    - 일반적으로 nosql 보다 ACID 트랜잭션을 지원하는 전통적인 rdms를 선호함
- 복식부기 원장 시스템
    - 복식부기는 모든 결제 시스템의 필수요소이며 정확한 기록을 남기는 데 핵심적인 역할을 한다
    - 누군가 1센트를 차감하면 다른 누군가는 1센트를 가져가야 한다
    - 모든 거래 항목의 합계는 0이어야 함
        
        ![KakaoTalk_20240528_151735259.jpg]({{ "/assets/img/study/books/system-design-interview-vol2/chapter11/KakaoTalk_20240528_151735259.jpg" | relative_url }})
        
- 외부 결제 페이지
    - 대부분 기업은 신용카드 정보를 내부에 저장하지 않는데, 이는 저장할 경우 미국의
    PCI DSS 같은 복잡한 규정을 준수 해야하기 때문
    - 이를 위해 PSP가 제공하는 외부 결제 페이지를 사용함

### 3단계: 상세 설계

- PSP 연동
    - 결제시스템이 직접 카드사와 연결할수 있다면 PSP없이도 결제 가능하지만 흔치 않다
    - PSP와 연동하는 두 가지 방법
        - PSP와 API를 통한 연동
        - 외부 결제 페이지를 제공 (대부분 기업이 택하는 접근법)
- 조정
    - 시스템의 구성 요소가 비동기적으로 통신할 경우 응답이 반환된다는 보장이 없다
    - 이를 위해 조정 과정을 거치며, 일반적으로 결제 시스템의 마지막 방어선
    - 관련 서비스 간의 상태를 주기적으로 비교하며 확인하는 방법으로 PSP나 은행의 정산 내역과 결제시스템 내부의 데이터간 일관성 확인
        - 불일치 할 경우 자동화 프로그램을 통해 해결하거나 안될경우 재무팀에서 수동으로 처리함
    - 옆동네의 후불결제에서도 이와 같은 대사 과정을 배치를 통해 수행함
- 결제 지연 처리
    - 대부분 결제는 몇 초안에 처리되지만 몇 시간 또는 며칠이 걸리는 경우도 있다
        - PSP가 해당 결제의 위험성이 높다고 보고 검토를 요구하는 경우
        - 구매자가 사용한 카드가 본인 것인지 확인하는 경우
    - 이런식으로 지연될 경우 상태가 바뀌면 PSP에서 웹훅을 이용하여 호출하거나, 혹은 결제시스템이 주기적으로 폴링을 하기도 한다
- 내부 서비스간 커뮤니케이션
    - 동기식 통신
        - 소규모 시스템에서는 잘 작동하나 규모가 커지면 단점이 분명해짐
            - 성능저하
            - 장애 격리 곤란
            - 높은 결합도
            - 낮은 확장성
    - 비동기 통신
        - 단일 수신자
            - 각 요청은 하나의 수신자 또는 서비스가 처리함. 복수의 구독자가 있을수 있으나 처리된 메시지는 바로 큐에서 제거되어 중복 실행을 방지함
        - 다중 수신자
            - 각 요청에 대하여 여러 수신자 또는 서버가 처리
            - 여러 수신자가 존재하나 각기 역할을 다르게 하는 방법
                - 하나의 요청으로 알림 전송, 결제요청, 분석 등 처리
            - 카프카가 이런 프로세스를 잘 수행한다고 함
- 결제 실패 처리
    - 결제 상태 추적
        - 실패가 일어날 때마다 상태를 파악하고 재시도 또는 환불 여부를 결정함
    - 재시도 큐 및 실패 메시지 큐
        - 재시도 큐: 일시적 오류일 경우 재시도 큐에 보냄
        - 실메 메시지 큐: 반복적으로 실패한 메시지를 보내서 처리함
- 정확히 한 번 전달
    - 결제 시스템에서 가장 심각한 문제중 하나는 고객에게 이중으로 청구하는 것
    - 언뜻보면 정확히 한 번 전달하는것이 어렵게 느껴질 수 있으나 문제를 두 부분으로 나누면 훨씬 쉬워진다!
        - 최소 한 번은 실행된다
        - 최대 한 번 실행된다
    - 이거랑 뭐가 다름????
    
    ![Untitled]({{ "/assets/img/study/books/system-design-interview-vol2/chapter11/Untitled.png" | relative_url }})
    
- 재시도
    - 최소 한번 실행을 위한 수
    - 간혹 네트워크 오류나 시간 초과 등으로 인하여 결제를 다시 시도해야 하는 경우가 있다
    - 재시도 메커니즘
        - 즉시 재시도
        - 고정 간격: 재시도 전에 일정 간격을 기다림
        - 증분 간격: 재시도 전에 기다리는 시간을 특정한 양만큼 점진적으로 늘려감
        - 지수적 백오프: 재시도 전에 기다리는 시간을 직전 대비 2배로 늘려나가는 방법
        1회차 1초 대기, 2회차 2초 대기, 3회차 4초 대기
        - 취소: 성공 가능성이 낮다고 판명되면 결국 취소함
    - 적절한 재시도 전략을 결정하는 것은 어렵다. 모든 상황에 맞는 해결책은 없으나 일반적으로 적용 가능한 지침으로 문제가 단기간에 해결될것 같지 않다면 지수적 백오프를 사용하라는 것
    - 지나친 재시도는 컴퓨팅 자원 낭비, 서비스 과부하 유발 그리고 이중결제까지 유발할 수 있다
- 멱등성
    - 최대 한 번 실행을 하기 위한 핵심 개념
    - 여러번 실행하더라도 최초 실행 결과가 그대로 보존되는 특성
    - 클라이언트 → 서버 간 통신을 위해서 멱등키 값으로 UUID 사용을 권장하며 실제로 널리 쓰임
    - 동일한 멱등 키로 많은 요청을 받게 될 경우 그 중 하나만 처리하고 나머지에 대해서는 
    429 Too Many Request를 반환
- 일관성
    - 결제 실행 과정에서 상태정보를 유지 관리하는 여러 서비스가 호출되기 마련이나,
    분산 환경에서는 서비스간 통신 실패로 데이터 불일치가 발생할 수 있다
    - 내부 서비스와 외부 서비스 간의 데이터 일관성 유지를 위해서 멱등성과 조정 프로세스를 사용한다
    - 외부 서비스에서 멱등 API를 지원하더라도 항상 옳다고 할 수 없으므로 조정 절차를 생략할 수 없다
    - 데이터를 다중화 하는 과정에서 복제 지연으로 인해 불일치가 발생할 수 있는데
    이를 해결하기 위한 2가지 방법이 있다
        - 일반적인 rdbms 구조중 하나인 master(RW) - slave(R)
        - 모든 사본이 항상 동기화되도록 처리. 합의 알고리즘 및 합의 기반 분산 DB 사용
- 결제 보안
    
    ![KakaoTalk_20240528_164449124.jpg]({{ "/assets/img/study/books/system-design-interview-vol2/chapter11/KakaoTalk_20240528_164449124.jpg" | relative_url }})
    

### 4단계: 마무리

- 여러가지 주제를 다뤘지만 아직 언급할 가치가 있는 주제가 많이 남아 있다
결제 시스템을 만들때 중요한 요소들은 이런 것들이 있다
    - 모니터링
    - 경보
    - 디버깅 도구
    - 환율
    - 지역
    - 현금결제
    - 구글/애플페이 연동
---
layout: post
title:  "03. 저장소와 검색 - Section 1"
date:   2024-07-22 00:00:00 +0900
categories: study books data-intensive-applications
author: 유석모
announced_on: 2024년 7월 25일
---
## 들어가며

> **데이터베이스**: 데이터 저장과 조회의 2가지 작업 수행

이번 장은 2가지를 다룸<br/>

1. 데이터베이스가 데이터를 저장하는 방법<br/>
2. 데이터를 요청했을 때 다시 찾을 수 있는 방법

다루는 데이터베이스 종류

1. RDB
2. NoSQL DB
3. log-structured 게열 저장소 엔진
4. page-oriented 계열 저장소 엔진

<br/>
## DB를 강력하게 만드는 데이터 구조

### 세상에서 제일 간단한 데이터베이스

- 키-값 저장소
- 추가 전용(append-only) 데이터 파일인인 `log`를 사용
    > `log`란 연속된 추가 전용 레코드<br/>
    > thread-safe 읽기를 보장

- `db_get key`를 호출하면 연관된 가장 최근 값을 찾아 반환

```sh
#!/bin/bash

db_set () {
    echo "$1,$2" >> database
}

db_get () {
    grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

<div class="area-1">
    <div class="cli-container">
        <div class="cli-wrapper console-1">
            <div class="title">
                <code>functions.sh</code>
            </div>
            <textarea id="console-1" class="cli console-1" rows="16" value="$ "></textarea>
        </div>
        <div class="cli-wrapper file-1">
            <div class="title">
                <code>database</code>
            </div>
            <div class="cli file-1">
                <p id="file-1"></p>
            </div>
        </div>
    </div>
</div>

- 검색 비용 `O(n)`으로 비효율적<br/>
    -\> **색인**을 도입하여 특정 키의 값을 효율적으로 찾는 데이터 구조를 구현

### 색인(index)
부가적인 메타데이터를 유지
- 기본 데이터(primary data)에서 파생한 **추가적인** 구조
- 데이터베이스의 내용에는 영향을 미치지 않음<br/>
    -\> 질의 성능에만 영향
- 어떤 종류의 색인이라도 대개 쓰기 속도를 느리게 만듦<br/>
    -\> 데이터 쓰기 시 색인 갱신 필요

저장소 시스템에서 **중요한 트레이드오프**
- 색인을 잘 선택하면 읽기 질의 속도가 향상 but 모든 색인은 쓰기 속도를 느리게 함
- 색인은 개발자나 DBA가 수동으로 색인 선택 필요<br/>
    -\> 필요 이상의 오버헤드 지양, 애플리케이션에 가장 큰 이익을 안겨주는 색인 선택

### 해시 색인
- 키-값 데이터를 색인하는 경우 검토
- 색인 전략
    - 키를 데이터 파일의 바이트 오프셋에 매핑
    - 인메모리 해시 맵 유지

![Figure 3-1]({{ "/assets/img/study/books/data-intensive-applications/chapter03/section1/figure3-1.png" | relative_url }})

- Bitcask(Riak의 기본 저장소 엔진)가 사용하는 방식
    - 해시 맵을 전부 메모리에 유지
    - 사용 가능한 램에 모든 키가 저장된다는 조건을 전제
    - 고성능 읽기, 쓰기 보장

> [Riak](https://en.wikipedia.org/wiki/Riak): 분산 NoSQL 키-값 저장소<br/>
> 고가용성, 내결함성, 조작의 간편함, 확장성을 특징으로 함<br/>
> GitHub, AT&T, Riot Games 등에서 사용

- 각 키의 값이 자주 갱신되는 상황에 매우 적합
    - 예시로 키는 고양이 동상의 URL, 값은 비디오가 재생된 횟수

- append-only 방식은 디스크 공간 부족을 초래
    - 특정 크기의 **segment**로 로그를 나누는 방식이 좋은 해결책
    - 특정 크기에 도달하면 segment 파일을 닫고 새로운 segment 파일에 쓰기를 수행
    - segment 파일들에 대해 **compaction**을 수행할 수 있음
    - compaction은 로그에서 중복된 키를 버리고 최신 갱신 값만 유지하는 것

- compaction은 보통 segment를 더 작게 만들기 때문에 여러 segment들을 병합 가능
    - segment가 쓰여진 후에는 절대 변경할 수 없기 때문에 새로운 파일로 생성
    - segment 병합과 compaction은 백그라운드 스레드에서 고정 작업 수행 가능
    - 병합 과정이 끝난 이후에는 병합된 segment를 사용하게끔 전환
    - 전환 후 이전 segment 파일을 삭제

![Figure 3-3]({{ "/assets/img/study/books/data-intensive-applications/chapter03/section1/figure3-3.png" | relative_url }})

- 해시 색인 활용 질의 과정
    - 사용자가 특정 키의 데이터 요청
    - 최신 segment 해시 맵에서 키 확인
    - 키가 없다면 두 번째 최신 segment 등을 확인
    - 확인 된 바이트 오프셋으로 파일에서 조회

- 실제 구현에서 중요한 문제
    - 파일 형식: 바이트 단위의 문자열 길이, 원시 문자열을 각각 부호화(encoding)
    - 레코드 삭제: 삭제 레코드(a.k.a tombstone)를 표시 후 병합 과정에서 제거
    - 고장 복구: segment 해시 맵 스냅샷을 디스크에 저장 후 DB 재시작 시 로드
    - 부분적으로 레코드 쓰기: 체크섬을 함께 저장
    - 동시성 제어: 
        - 엄격하게 제어하려면 쓰기 시 단일 스레드 사용,
        - 읽기 시는 데이터 파일 세그먼트의 추가 전용 또는 불변(immutable) 특성으로 인해 다중 스레드로 동시 읽기 가능

- 해시 테이블 색인의 제한 사항
    - 메모리 저장 시 키가 너무 많으면 문제가 된다.
        - 디스크에 해시 맵을 유지할 수 있지만 무작위 접근 I/O가 많이 필요하고, 디스크 확장 비용이 비싸며, 해시 충돌 해소가 복잡하다.
    - 범위 질의(range query)에 비효율적이다.
        - kitty00000과 kitty99999 사이 모든 키를 쉽게 스캔할 수 없다.
        - 해시 맵에서 모든 개별 키를 조회해야한다.

<br/>
## SS테이블과 LSM 트리
- SS테이블: Sorted String Table
- LSM 트리: Log-Structued Merge-Tree(로그 구조화 병합 트리)

키로 정렬하면 비정렬 구조보다 많은 장점이 있다.
1. 병합 정렬이 가능하다.<br/>
    새로 만든 세그먼트 파일도 역시 키로 정렬돼 있다.
2. 특정 키를 찾기 위해 메모리에 모든 키의 색인을 유지할 필요가 없다.<br/>
    정렬돼 있으므로 키 a와 c 사이에 키 b가 존재한다는 것을 활용
3. 희소 색인(sparse index)에서 색인되지 않은 세그먼트 블록은 압축하여 I/O 대역폭 사용을 줄일 수 있다.
4. 범위 질의를 효율적으로 실행할 수 있다.(최소\~최대 모든 키 스캔)<br/>
    순차적 디스크 접근으로 효율적
### SS 테이블의 유지
- red-black tree나 AVL 트리 등 균형 트리(balanced tree) 활용
    - 임의의 순서로 키를 삽입하고 정렬된 순서로 해당 키를 다시 읽을 수 있다.

**SS 테이블을 활용한 저장소 엔진**
- memtable: 인메모리 balanced tree에 데이터 저장
- memtable의 크기가 임곗값보다 커지면 SS테이블 파일로 디스크에 기록
- 읽기 요청 시 memtable > 최신 세그먼트 > 그 다음 세그먼트 등 순서로 조회
- 백그라운드로 세그먼트 내 삭제된 값을 버리는 병합과 컴팩션 과정을 수행

### SS테이블에서 LSM 트리 만들기
LSM 트리를 디스크에 저장한 구현 중의 하나가 SS테이블
- ex. Lucene
    - term dictionary
        - 키를 term으로, 값은 단어를 포함한 모든 postings list
        - SS테이블 같은 정렬 파일에 유지

### 성능 최적화
- DB에 존재하지 않는 키를 찾는 경우
    - 모든 세그먼트를 열어봐야해서 비효율적
    - 블룸 필터(Bloom filter) 사용으로 해결: 디스크 읽기 절약
        <details>
        <blockquote>
        <b>블룸 필터(Bloom filter)</b>는 원소가 집합에 속하는지 여부를 검사하는데 사용되는 확률적 자료 구조이다. <a href="https://ko.wikipedia.org/wiki/%EB%B8%94%EB%A3%B8_%ED%95%84%ED%84%B0">#</a><br/>
        키가 존재한다했는데 실제로 없는 경우는 있어도(긍정 오류),<br/>
        <b>키가 없다했는데 실제로 있는 경우는 없다(부정 오류)</b>.<br/>
        bit 배열에서 k가지 해시 위치에 1로 마스킹하여 조회 시 해시 위치에 0이 존재하면 값이 존재하지 않음으로 판단<br/>
        <img src="{{ "/assets/img/study/books/data-intensive-applications/chapter03/section1/bloom-filter.png" | relative_url }}" alt="bloom-filter"/>
        </blockquote>
        </details>
    - SS테이블의 압축 및 병합 전략
        - 크기 계층 컴팩션(size-tiered compaction)
            - ex. HBase, Cassandra
        - 레벨 컴팩션(leveled compaction)
            - ex. LevelDB, [RocksDB](https://github.com/facebook/rocksdb/wiki/Leveled-Compaction), Cassandra
            - 디스크 사용이 효율적이다.<br/>
                <img src="{{ "/assets/img/study/books/data-intensive-applications/chapter03/section1/leveled-compaction-3.webp" | relative_url }}" alt="leveled-compaction" width="480px"/>
                
## B 트리(B-tree)











<!---------------------- script ---------------------->
<script type="text/javascript">
window.onload = () => {
    const console1 = document.querySelector('#console-1');
    const file1 = document.querySelector('#file-1');

    let text = '$ ';
    let cursor = 2;
    let database = `123456,{"name":"London","attractions":["Big Ben","London Eye"]}
42,{"name":"San Francisco","attractions":["Golden Gate Bridge"]}
42,{"name":"San Francisco","attractions":["Exploratorium"]}
`;
    let lastInput = [];
    let lastIndex = 0;

    console1.value = text;
    file1.innerText = database;

    console1.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            const end = console1.value.length;
            if (end === cursor) {
                return;
            }
            const input = console1.value.slice(cursor, end);
            text = console1.value + "\n";

            args = input.split(' ');
            switch (args[0].toLowerCase()) {
                case 'clear':
                case 'cls':
                    text = '$ ';
                    cursor = 2;
                    console1.value = text;
                    break;
                case 'db_set':
                    if (args.length <= 2) {
                        text += "db_set needs at least 2 arguments."
                    } else {
                        text += "done."
                        database += args[1] + "," + args[2] + "\n";
                        file1.innerText = database;
                    }
                    text += "\n\n$ ";
                    break;
                case 'db_get':
                    if (args.length <= 1) {
                        text += "db_get needs at least 1 arguments."
                    } else {
                        matches = database.split('\n')
                            .filter(i => i.startsWith(args[1] + ','))
                            .map(i => i.slice(args[1].length + 1));
                        if (matches.length > 0) {
                            text += matches[matches.length - 1];
                        } else {
                            text += "no record was found.";
                        }
                        file1.innerText = database;
                    }
                    text += "\n\n$ ";
                    break;
                case 'db_compact':
                    dict = {};
                    database.split('\n')
                        .forEach(it => {
                            const index = it.indexOf(',');
                            if (index >= 0) {
                                const key = it.slice(0, index);
                                const value = it.slice(index + 1, it.length);
                                dict[key] = value; 
                            }
                        });
                    
                    database = '';
                    for (let key of Object.keys(dict)) {
                        database += key + ',' + dict[key] + '\n';
                    }
                    
                    text += "done.";
                    file1.innerText = database;

                    text += "\n\n$ ";
                    break;
                case 'db_drop':
                    database = '';
                    text += "done.";
                    file1.innerText = database;

                    text += "\n\n$ ";
                    break;
                case 'cat':
                    if (args.length <= 1) {
                        text += "cat needs at least 1 arguments."
                    } else {
                        if (args[1] === 'database') {
                            text += database;
                        } else {
                            text += "file not exists.";
                        }
                    }
                    text += "\n\n$ ";
                    break;
                case 'ls':
                    text += "database\n\n$ ";
                    break;
                default:
                    text += "unknown command.";
                    text += "\n\n$ ";
                    break;
            }
            lastInput.push(input);
            lastIndex = lastInput.length - 1;

            console1.value = text;
            cursor = text.length;
            console1.scrollTop = console1.scrollHeight;
        } else {
            if (console1.selectionStart < cursor) {
                e.preventDefault();
                console1.value += e.key;
                console1.selectionStart = console1.value.length;
            }
        }
    });

    console1.addEventListener('keydown', (e) => {
        switch (e.key) {
            case 'Backspace':
                const end = console1.value.length;
                if (cursor >= end) {
                    e.preventDefault();
                }
                break;
            case 'ArrowUp':
                e.preventDefault();
                if (lastInput.length === 0) {
                    break;
                }
                console1.value = text + lastInput[lastIndex];
                --lastIndex;
                if (lastIndex < 0) {
                    lastIndex = lastInput.length - 1;
                }
                break;
            case 'ArrowDown':
                e.preventDefault();
                if (lastInput.length === 0) {
                    break;
                }
                console1.value = text + lastInput[lastIndex];
                ++lastIndex;
                if (lastIndex > lastInput.length - 1) {
                    lastIndex = 0;
                }
                break;
            default:
                break;
        }
    });

    console1.addEventListener('input', (e) => {
        if (cursor > console1.value.length) {
            console1.value = text;
        }
    });
};
</script>


<!---------------------- style ---------------------->
<style type="text/css">

.area-1 {
    display: flex; 
    justify-content: center; 
    padding: 2rem 2rem 3rem 2rem;
}

.cli-container {
    display: flex; 
    width: 100%;
}

.cli-wrapper {
    flex: 1 1; 
    display: flex;
    flex-direction: column;
}

.cli-wrapper .title {
    flex: 0 1;
    margin: 0.5rem 0;
}

.cli {
    flex: 1 1;
    background: black; 
    color: white;
    font: 0.875rem Consolas, Monaco, D2 Coding, monospace;
    padding: 1rem;
}

.cli.console-1 {
    text-align: left;
    resize: none;
}

.cli.file-1 {
    height: 100%;
    overflow: scroll;
}

.cli-wrapper.file-1 p {
    margin: 0;
    margin-block-start: 0;
    margin-block-end: 0;
}

.cli-wrapper.console-1 {
    margin-right: 1rem;
}

.cli-wrapper.console-1:focus {
    outline: none;
}

@media print, screen and (max-width: 960px) {
    .area-1 {
        padding: 2rem 0rem 3rem 0rem;
    }

    .cli-container {
        width: 100%;
        flex-direction: column;
    }

    .cli-wrapper.console-1 {
        margin: 0;
    }

    .cli-wrapper.file-1 p {
        height: 15rem;
    }
}

</style>
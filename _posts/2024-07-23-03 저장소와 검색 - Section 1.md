---
layout: post
title:  "03. 저장소와 검색 - Section 1"
date:   2024-07-20 00:00:00 +0900
categories: study books data-intensive-applications
author: 유석모
announced_on: 2024년 7월 23일
---
## 들어가며

> **데이터베이스**: 데이터 저장과 조회의 2가지 작업 수행

이번 장은 2가지를 다룸<br/>

1. 데이터베이스가 데이터를 저장하는 방법<br/>
2. 데이터를 요청했을 때 다시 찾을 수 있는 방법

다루는 데이터베이스 종류

1. RDB
2. NoSQL DB
3. log-structured 게열 저장소 엔진
4. page-oriented 계열 저장소 엔진

<br/>
## DB를 강력하게 만드는 데이터 구조

### 세상에서 제일 간단한 데이터베이스

- 키-값 저장소
- 추가 전용(append-only) 데이터 파일인인 `log`를 사용
    > `log`란 연속된 추가 전용 레코드

- `db_get key`를 호출하면 연관된 가장 최근 값을 찾아 반환

```sh
#!/bin/bash

db_set () {
    echo "$1,$2" >> database
}

db_get () {
    grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

<div class="area-1">
    <div class="cli-container">
        <div class="cli-wrapper console-1">
            <div class="title">
                <code>functions.sh</code>
            </div>
            <textarea id="console-1" class="cli console-1" rows="16" value="$ "></textarea>
        </div>
        <div class="cli-wrapper file-1">
            <div class="title">
                <code>database</code>
            </div>
            <div class="cli file-1">
                <p id="file-1"></p>
            </div>
        </div>
    </div>
</div>

- 검색 비용 `O(n)`으로 비효율적<br/>
    -\> **색인**을 도입하여 특정 키의 값을 효율적으로 찾는 데이터 구조를 구현

### 색인(index)
부가적인 메타데이터를 유지
- 기본 데이터(primary data)에서 파생한 **추가적인** 구조
- 데이터베이스의 내용에는 영향을 미치지 않음<br/>
    -\> 질의 성능에만 영향
- 어떤 종류의 색인이라도 대개 쓰기 속도를 느리게 만듦<br/>
    -\> 데이터 쓰기 시 색인 갱신 필요

저장소 시스템에서 **중요한 트레이드오프**
- 색인을 잘 선택하면 읽기 질의 속도가 향상 but 모든 색인은 쓰기 속도를 느리게 함
- 색인은 개발자나 DBA가 수동으로 색인 선택 필요<br/>
    -\> 필요 이상의 오버헤드 지양, 애플리케이션에 가장 큰 이익을 안겨주는 색인 선택

### 해시 색인
- 키-값 데이터를 색인하는 경우 검토
- 색인 전략
    - 키를 데이터 파일의 바이트 오프셋에 매핑
    - 인메모리 해시 맵 유지

![Figure 3-1]({{ "/assets/img/study/books/data-intensive-applications/chapter03/section1/figure3-1.png" | relative_url }})

- Bitcask(Riak의 기본 저장소 엔진)가 사용하는 방식
    - 해시 맵을 전부 메모리에 유지
    - 사용 가능한 램에 모든 키가 저장된다는 조건을 전제
    - 고성능 읽기, 쓰기 보장

> [Riak](https://en.wikipedia.org/wiki/Riak): 분산 NoSQL 키-값 저장소<br/>
> 고가용성, 내결함성, 조작의 간편함, 확장성을 특징으로 함<br/>
> GitHub, AT&T, Riot Games 등에서 사용

- 각 키의 값이 자주 갱신되는 상황에 매우 적합
    - 예시로 키는 고양이 동상의 URL, 값은 비디오가 재생된 횟수

- append-only 방식은 디스크 공간 부족을 초래
    - 특정 크기의 **segment**로 로그를 나누는 방식이 좋은 해결책
    - 특정 크기에 도달하면 segment 파일을 닫고 새로운 segment 파일에 쓰기를 수행
    - segment 파일들에 대해 **compaction**을 수행할 수 있음
    - compaction은 로그에서 중복된 키를 버리고 최신 갱신 값만 유지하는 것

- compaction은 보통 segment를 더 작게 만들기 때문에 여러 segment들을 병합 가능
    - segment가 쓰여진 후에는 절대 변경할 수 없기 때문에 새로운 파일로 생성
    - segment 병합과 compaction은 백그라운드 스레드에서 고정 작업 수행 가능
    - 병합 과정이 끝난 이후에는 병합된 segment를 사용하게끔 전환
    - 전환 후 이전 segment 파일을 삭제

![Figure 3-3]({{ "/assets/img/study/books/data-intensive-applications/chapter03/section1/figure3-3.png" | relative_url }})

- 색인 활용 질의 과정
    - 사용자가 특정 키의 데이터 요청
    - 최신 segment 해시 맵에서 키 확인
    - 키가 없다면 두 번째 최신 segment 등을 확인
    - 확인 된 바이트 오프셋으로 파일에서 조회

<br/>
## SS테이블과 LSM 트리












<!---------------------- script ---------------------->
<script type="text/javascript">
window.onload = () => {
    const console1 = document.querySelector('#console-1');
    const file1 = document.querySelector('#file-1');

    let text = '$ ';
    let cursor = 2;
    let database = `123456,{"name":"London","attractions":["Big Ben","London Eye"]}
42,{"name":"San Francisco","attractions":["Golden Gate Bridge"]}
42,{"name":"San Francisco","attractions":["Exploratorium"]}
`;
    let lastInput = [];
    let lastIndex = 0;

    console1.value = text;
    file1.innerText = database;

    console1.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            const end = console1.value.length;
            if (end === cursor) {
                return;
            }
            const input = console1.value.slice(cursor, end);
            text = console1.value + "\n";

            args = input.split(' ');
            switch (args[0].toLowerCase()) {
                case 'clear':
                case 'cls':
                    text = '$ ';
                    cursor = 2;
                    console1.value = text;
                    break;
                case 'db_set':
                    if (args.length <= 2) {
                        text += "db_set needs at least 2 arguments."
                    } else {
                        text += "done."
                        database += args[1] + "," + args[2] + "\n";
                        file1.innerText = database;
                    }
                    text += "\n\n$ ";
                    break;
                case 'db_get':
                    if (args.length <= 1) {
                        text += "db_get needs at least 1 arguments."
                    } else {
                        matches = database.split('\n')
                            .filter(i => i.startsWith(args[1] + ','))
                            .map(i => i.slice(args[1].length + 1));
                        if (matches.length > 0) {
                            text += matches[matches.length - 1];
                        } else {
                            text += "no record was found.";
                        }
                        file1.innerText = database;
                    }
                    text += "\n\n$ ";
                    break;
                case 'db_compact':
                    dict = {};
                    database.split('\n')
                        .forEach(it => {
                            const index = it.indexOf(',');
                            if (index >= 0) {
                                const key = it.slice(0, index);
                                const value = it.slice(index + 1, it.length);
                                dict[key] = value; 
                            }
                        });
                    
                    database = '';
                    for (let key of Object.keys(dict)) {
                        database += key + ',' + dict[key] + '\n';
                    }
                    
                    text += "done.";
                    file1.innerText = database;

                    text += "\n\n$ ";
                    break;
                case 'db_drop':
                    database = '';
                    text += "done.";
                    file1.innerText = database;

                    text += "\n\n$ ";
                    break;
                case 'cat':
                    if (args.length <= 1) {
                        text += "cat needs at least 1 arguments."
                    } else {
                        if (args[1] === 'database') {
                            text += database;
                        } else {
                            text += "file not exists.";
                        }
                    }
                    text += "\n\n$ ";
                    break;
                case 'ls':
                    text += "database\n\n$ ";
                    break;
                default:
                    text += "unknown command.";
                    text += "\n\n$ ";
                    break;
            }
            lastInput.push(input);
            lastIndex = lastInput.length - 1;

            console1.value = text;
            cursor = text.length;
            console1.scrollTop = console1.scrollHeight;
        } else {
            if (console1.selectionStart < cursor) {
                e.preventDefault();
                console1.value += e.key;
                console1.selectionStart = console1.value.length;
            }
        }
    });

    console1.addEventListener('keydown', (e) => {
        switch (e.key) {
            case 'Backspace':
                const end = console1.value.length;
                if (cursor >= end) {
                    e.preventDefault();
                }
                break;
            case 'ArrowUp':
                e.preventDefault();
                if (lastInput.length === 0) {
                    break;
                }
                console1.value = text + lastInput[lastIndex];
                --lastIndex;
                if (lastIndex < 0) {
                    lastIndex = lastInput.length - 1;
                }
                break;
            case 'ArrowDown':
                e.preventDefault();
                if (lastInput.length === 0) {
                    break;
                }
                console1.value = text + lastInput[lastIndex];
                ++lastIndex;
                if (lastIndex > lastInput.length - 1) {
                    lastIndex = 0;
                }
                break;
            default:
                break;
        }
    });

    console1.addEventListener('input', (e) => {
        if (cursor > console1.value.length) {
            console1.value = text;
        }
    });
};
</script>


<!---------------------- style ---------------------->
<style type="text/css">

.area-1 {
    display: flex; 
    justify-content: center; 
    padding: 2rem 2rem 3rem 2rem;
}

.cli-container {
    display: flex; 
    width: 100%;
}

.cli-wrapper {
    flex: 1 1; 
    display: flex;
    flex-direction: column;
}

.cli-wrapper .title {
    flex: 0 1;
    margin: 0.5rem 0;
}

.cli {
    flex: 1 1;
    background: black; 
    color: white;
    font: 0.875rem Consolas, Monaco, D2 Coding, monospace;
    padding: 1rem;
}

.cli.console-1 {
    text-align: left;
    resize: none;
}

.cli.file-1 {
    height: 100%;
    overflow: scroll;
}

.cli-wrapper.file-1 p {
    margin: 0;
    margin-block-start: 0;
    margin-block-end: 0;
}

.cli-wrapper.console-1 {
    margin-right: 1rem;
}

.cli-wrapper.console-1:focus {
    outline: none;
}

@media print, screen and (max-width: 960px) {
    .area-1 {
        padding: 2rem 0rem 3rem 0rem;
    }

    .cli-container {
        width: 100%;
        flex-direction: column;
    }

    .cli-wrapper.console-1 {
        margin: 0;
    }

    .cli-wrapper.file-1 p {
        height: 15rem;
    }
}

</style>
---
layout: post
title:  "05. 복제 - Section 1, 2"
date:   2024-08-13 12:00:00 +0900
categories: study books data-intensive-applications
author: 홍성민
announced_on: 2024년 8월 13일
---
# 05. 복제 - Section 1, 2

복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미다. 

![image.png]({{ "/assets/img/study/books/data-intensive-applications/chapter05/section1-2/image.png" | relative_url }})

복제가 필요한 3가지 이유는 다음과 같다.

- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다.
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

이번 장에서는 데이터셋이 아주 작아 각 장비에 전체 데이터셋의 복사본을 보유할 수 있다고 가정한다. 너무 큰 데이터셋을 대상으로 한 파티셔닝은 6장에서 살펴본다.

복제에서 모든 어려움은 복제된 데이터의 변경 처리에 있다. 노드 간 변경을 복제하기 위한 세 가지 인기 있는 알고리즘인 단일리더, 다중리더, 리더 없는 복제를 살펴보자.

# 리더와 팔로워

복사본을 저장하는 노드를 replica라고 한다. 모든 복제 서버에 모든 데이터가 있다는 사실을 어떻게 보장할 수 있을까?

데이터베이스의 모든 쓰기는 모든 복제 서버에서 처리돼야 한다. 그렇지 않으면 복제 서버는 더 이상 동일한 데이터를 유지할 수 없다. 일반적인 해결책은 리더 기반 복제이며 그림 5-1에 나와 있다.

![image.png]({{ "/assets/img/study/books/data-intensive-applications/chapter05/section1-2/image%201.png" | relative_url }})

복제 서버 중 하나를 리더로 지정한다. 클라이언트가 데이터베이스에 쓰기를 할 때 클라이언트는 요청을 리더에게 보내야 한다. 리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다. 다른 복제 서버는 팔로워(follower)라고 한다. 리더가 로컬 저장소에 새로운 데이터를 기록할 떄마다 데이터 변경을 복제 로그나 변경 스트림의 일부로 팔로워에게 전송한다. 각 팔로워가 리더로부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 그에 맞게 데이터베이스의 로컬 복사본을 갱신한다.

 클라이언트가 데이터베이스로부터 읽기를 할 때는 리더 또는 임의 팔로워에게 질의할 수 있다. 하지만 쓰기는 리더에게만 허용된다. 팔로워는 클라이언트 관점에서는 읽기 전용이다.

이 복제 모드는 포스트그레스큐엘(9.0버전 부터), MySQL, 오라클 데이터 가드, SQL 서버의 상시 가용성 그룹과 같은 여러 관계형 데이터베이스에 내장된 기능이다. 또한 MongoDB, 리싱크DB, 에스프레소를 포함한 일부 비관계형 데이터베이스에서도 사용한다. 카프카와 RabbitMQ의 고가용성 큐 같은 분산 메시지 브로커에도 사용된다.

## 동기식 대 비동기식 복제

복제 시스템의 중요한 세부 사항은 복제가 동기식으로 발생하는지 비동기식으로 발생하는지 여부다. 그림 5-1에서 웹사이트 사용자가 이미지를 갱신하는 상황을 생각해보자. 어떤 시점에 리더는 데이터 변경을 팔로워에게 전달한다. 최종적으로 리더는 클라이언트에게 갱신이 성공했음을 알려준다.

![image.png]({{ "/assets/img/study/books/data-intensive-applications/chapter05/section1-2/image%202.png" | relative_url }})

팔로워 1의 복제는 동기식이다. 팔로워 2의 복제는 비동기식이다. 보통 1초 내에 팔로워에게 변경 내용을 적용하지만 얼마나 오래 걸릴지는 보장할 수 없다. 팔로워가 수분 이상 리더와 떨어질 수 있다. 팔로워가 장애를 복구 중이거나 시스템이 최대 가용량 부근에서 동작하거나 노드 간 네트워크 문제가 있을 수 있기 때문이다.

동기식 복제의 장점은 팔로워가 리더와 일관성 있게 최신 데이터의 복사본을 가지는 것을 보장한다. 갑자기 리더가 작동하지 않아도 데이터는 팔로워에서 계속 사용할 수 있음을 확신할 수 있다.  단점은 동기식 팔로워가 장애로 응답하지 않는 경우에 쓰기가 처리될 수 없다는 것이다. 리더는 모든 쓰기를 block하고 동기 복제 팔로워가 다시 사용할 수 있을 때까지 기다려야 한다.

이런 이유로 모든 팔로워가 동기식인 상황은 비현실적이다. 임의 한 노드의 장애는 전체 시스템을 멈추게 한다. 현실적으로 데이터베이스에서 동기식 복제를 사용하려면 보통 팔로워 하나는 동기식으로 하고 그 밖에는 비동기식으로 하는 것을 의미한다. 동기식 팔로워가 사용할 수 없게 되거나 느려지면 비동기식 팔로워 중 하나가 동기식이 된다. 이것은 적어도 두 노드에 데이터의 최신 복사본이 있는 것을 보장한다. 이런 설정을 반동기식(semi-synchronous)이라 한다.

보통 리더 기반 복제는 완전히 비동기식으로 구성한다. 리더가 잘못되고 복구할 수 없으면 팔로워에게 아직 복제되지 않은 모든 쓰기는 유실된다. 완전 비동기식 설정은 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있는 장점이 있다.

## 새로운 팔로워 설정

때때로 복제 서버를 늘리거나 장애 노드의 대체를 위해 새로운 팔로워를 설정해야 한다. 새로운 팔로워가 리더의 데이터 복제본을 정확히 가지고 있는지 어떻게 보장할까?

쓰기 잠금을 해서도 가능하지만 고가용성 목표에 부합하지 않는다. 다행히 팔로워 설정은 대개 중단시간 없이 수행할 수 있다. 그 과정은 개념적으로 다음과 같다.

![중년탐정 김정LOCK]({{ "/assets/img/study/books/data-intensive-applications/chapter05/section1-2/image%203.png" | relative_url }})

중년탐정 김정LOCK

1. 가능하다면 전체 데이터베이스를 잠그지 않고 리더의 데이터베이스 스냅숏을 일정 시점에 가져온다. 대부분의 데이터베이스는 백업이 필요하기 때문에 이 기능을 갖췄다. 일부는 MySQL의 Innobackupex같은 서드파티 도구가 필요하다.
2. 스냅숏을 새로운 팔로워 노드에 복사한다.
3. 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청한다. 이것은 스냅숏이 리더의 복제 로그의 정확한 위치와 연관돼야 한다. 이 위치의 명칭은 다양하다. 예를 들어 포스트그레스큐엘에서는 로그 일련번호라하고 MySQL에서는 이진로그 좌표라 부른다.
4. 팔로워가 스냅숏 이후 데이터 변경의 미처리분(backlog)을 모두 처리했을 때 따라잡았다고 말한다. 이제부터 리더에 발생하는 데이터 변화를 이어 처리할 수 있다.

## 노드 중단 처리

시스템의 모든 노드는 장애로 인해 예기치 않게 중단될 수 있지만 계획된 유지보수로 인해 중단될 수도 있다.  리더 기반 복제에서 고가용성은 어떻게 달성할 수 있을까?

### 팔로워 장애: 따라잡기 복구

각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관한다. 팔로워가 죽어 재시작하거나 리더와 팔로워 사이의 네트워크가 일시적으로 중단된다면 팔로워는 매우 쉽게 복구할 수 있다. 먼저 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아낸다. 그러면 팔로워는 리더에 연결해 팔로워 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청할 수 있다. 이 변경이 다 적용되면 리더를 다 따라잡게 되고 이전과 같이 데이터 변경의 스트림을 계속 받을 수 있다.

### 리더 장애 : 장애 복구

리더 장애를 처리하는 일은 까다롭다. 팔로워 중 하나를 새로운 리더로 승격해야 하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하며 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다. 이 과정을 장애복구(failover)라 한다.

장애 복구는 수동으로 진행하거나 자동으로 진행한다. 자동 장애 복구는 보통 다음과 같은 단계로 구성된다.

1. 리더가 장애인지 판단한다. 대부분은 타임아웃을 사용해 리더 장애여부를 판단한다. 의도적으로 중단한 경우는 제외하고 말이다. 

![image.png]({{ "/assets/img/study/books/data-intensive-applications/chapter05/section1-2/image%204.png" | relative_url }})

1. 새로운 리더를 선택한다. 보통 이전 리더의 최신 데이터 변경사항을 가진 복제 서버다. 모든 노드가 새 리더 추대에 동의를 구하는 합의 문제는 9장에서 다룬다.
2. 새로운 리더 사용을 위해 시스템을 재설정한다. 클라이언트는 이제 새로운 쓰기 요청을 새로운 리더에게 보내야한다. 시스템은 문제가 생겼던 이전 리더가 돌아왔을 때 팔로워로 변경해주어야 한다.

장애 복구 과정은 잘못될 수 있는 것 투성이다.

- 비동기식 복제를 사용한다면 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수신하지 못할 수 있다. 새로운 리더가 선출된 다음 이전 리더가 클러스터에 다시 추가된다면 이 쓰기를 어떻게 해야 할까? 그 동안 새로운 리더가 충돌하는 쓰기를 수신했을지도 모른다. 가장 일반적인 해결책은 이전 리더의 복제되지 않은 쓰기를 단순히 폐기하는 방법이다. 이 방법은 내구성에 대한 클라이언트의 기대를 저버리게 된다.
- 쓰기를 폐기하는 방법은 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정돼야 한다면 특히 위험하다. 깃허브에서 발생한 사고 중 하나로 유효하지 않은 MySQL 팔로워가 리더로 승격된 사례가 있다. 데이터베이스는 새로운 로우의 기본키를 할당하기 위해 자동 증가 카운터를 사용했지만 새로운 리더의 카운터는 이전 리더보다 뒤처져 있었기 때문에 이전 리더가 예전에 할당한 기본키를 재사용했다. 이 기본키는 레디스 저장에도 사용했기 때문에 기본키의 재사용은 MySQL과 레디스 간 불일치를 일으켰다. 결국 일부 개인 데이터가 잘못된 사용자에게 공개됐다.
- 특정 결함 시나리오에서 두 노드가 모두 자신이 리더라고 믿을 수 있다. 이런 상황을 스플릿 브레인이라 한다. 스플릿 브레인은 매우 위험한 상황이다. 두 리더가 쓰기를 받으면서 충돌을 해소하는 과정을 거치지 않으면 데이터가 유실되거나 오염된다. 일부 시스템에서는 안전 장치로 두 리더가 감지되면 한 노드를 종료하는 매커니즘이 있다. 하지만 이 매커니즘을 주의깊게 설계하지 않으면 두 개의 노드가 모두 종료될 수 있다.

![image.png]({{ "/assets/img/study/books/data-intensive-applications/chapter05/section1-2/image%205.png" | relative_url }})

- 리더가 분명히 죽었다고 판단 가능한 적절한 타임아웃은 얼마일까? 긴 타임아웃은 리더가 작동하지 않을 때부터 복구까지 오랜 시간이 소요된다는 의미다. 하지만 타임아웃이 너무 짧으면 불필요한 장애 복구가 있을 수 있다. 예를 들어 일시적인 부하 급증으로 노드의 응답 시간이 타임아웃보다 커지거나 네트워크 고장으로 패킷이 지연되는 경우가 그렇다. 시스템이 이미 높은 부하나 네트워크 문제와 씨름 중이라면 불필요한 장애 복구가 상황을 더 악화시킬 수 있다.

이 문제에 대한 쉬운 해결책은 없다. 이런 이유로 일부 운영팀은 수동으로 장애 복구를 수행하는 방식을 선호한다.

노드 장애, 불안정한 네트워크, 복제 서버 일관성과 관련된 트레이드오프, 지속성, 가용성, 지연 시간 등의 문제는 사실 분산 시스템에서 발생하는 근본적인 문제다. 8,9장에서 이 같은 여러 문제를 좀 더 깊이 있게 살펴보겠다.

## 복제 로그 구현

실제로 다양한 복제 방법을 사용한다 이 방법들을 각각 간단히 살펴보자.

### 구문 기반 복제

리더는 모든 쓰기 요청을 기록하고 쓰기를 실행한 다음 구문 로그를 팔로워에게 전송한다. 관계형 데이터베이스는 모든 INSERT, UPDATE, DELETE 구문을 팔로워에게 전달하고 각 팔로워는 클라이언트에게 직접 받은 것처럼 SQL 구문을 파싱하고 실행한다.

이 접근법은 합리적인 것 같지만 복제가 깨질 수 있는 다양한 사례가 있다.

- 현재 날짜와 시간을 얻기 위한 NOW()나 임의 숫자를 얻기 위한 RAND() 같은 비결정적 함수를 호출하는 모든 구문은 각 복제 서버마다 다른 값을 생성할 가능성이 있다.
- 자동증가 칼럼을 사용하는 구문이나 데이터베이스에 있는  데이터에 의존한다면(예를 들어 UPDATE … WHERE <some condition>)구문은 각 복제 서버에서 정확히 같은 순서로 실행돼야 한다. 그렇지 않으면 효과가 달라질 수 있다. **이 방식은 동시에 여러 트랜잭션이 수행되는 것을 제한**하게 한다.
- 부수 효과를 가진 구문(예: 트리거, 스토어드 프로시저, 사용자 정의 함수)은 부수 효과가 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수 효과가 발생할 수 있다.

이 문제들은 대안 해결책이 있다. 예를 들어 리더는 구문을 기록할 때 모든 비결정적 함수 호출을 고정 값을 반환하게끔 대체할 수 있다. 그러면 팔로워는 모두 같은 값을 얻을 수 있다. 하지만 여러 엣지케이스가 있기 때문에 지금은 일반적으로 다른 복제 방법을 선호한다.

MySQL 5.1 이전 버전에서 구문 기반 복제가 사용됐다. 구문 기반 복제는 매우 간편해서 오늘날에도 여전히 사용된다. 하지만 MySQL은 이제 구문에 비결정성이 있다면 기본적으로 로우 기반 복제로 변경한다. 

### 쓰기 전 로그 배송

3장에서 모든 쓰기는 로그에 기록한다는 사실을 확인했다.

- 로그 구조화 저장소 엔진의 경우 로그 자체가 저장소의 주요 부분이다. 로그 세그먼트는 작게 유지되고 백그라운드로 가비지 컬렉션을 한다.
- 개별 디스크 블록에 덮어쓰는 B트리의 경우 모든 변경은 쓰기 전 로그에 쓰기 때문에 고장 이후 일관성 있는 상태로 색인을 복원할 수 있다.

두 경우 모두 로그는 데이터베이스의 모든 쓰기를 포함하는 추가 전용 바이트 열이다. 완전히 동일한 로그를 사용해 다른 노드에서 복제 서버를 구축할 수 있다. 리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 전송하기도 한다.

팔로워가 이 로그를 처리하면 리더에서 있는 것과 정확히 동일한 데이터 구조의 복제본이 만들어진다.

이 복제 방식은 포스트그레스큐엘과 오라클 등에서 사용된다. 가장 큰 단점은 로그가 제일 저수준의 데이터를 기술한다는 점이다. 데이터베이스가 저장소 형식을 다른 버전으로 변경한다면 대개 리더와 팔로워의 데이터베이스 소프트웨어 버전을 다르게 실행할 수 없다. 버전 불일치가 허용된다면 팔로워 먼저 소프트웨어 업그레이드를 하고 새로운 리더를 선정하는 식으로 중단시간 없이 업그레이드가 가능하다. (리더 선정과 클라이언트가 새로운 리더를 바라보게 하는 시간은 중단시간으로 볼 수 있지 않는가..ㅎ)

### 논리적(로우 기반) 로그 복제

복제 로그를 저장소 엔진 내부와 분리하기 위한 대안 하나는 복제와 저장소 엔진을 위해 다른 로그 형식을 사용하는 것이다. 이 같은 종류의 복제 로그를 저장소 엔진의 (물리적) 데이터 표현과 구별하기 위해 논리적 로그(logical log)라고 부른다.

관계형 데이터베이스용 논리적 로그는 대개 로우 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드 열이다.

- 삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함한다
- 삭제된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보를 포함한다. 보통 이것은 기본키지만 테이블에 기본키가 없다면 모든 칼럼의 예전 값을 로깅해야 한다.
- 갱신된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보와 모든 칼럼의 새로운 값(적어도 변경된 모든 칼럼의 새로운 값)을 포함한다.

여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랜잭션이 커밋됐음을 레코드에 표시한다. (로우 기반 복제를 사용하게끔 설정한 경우) MySQL의 이진 로그는 이 접근 방식을 사용한다.

논리적 로그를 저장소 엔진 내부와 분리했기 때문에 하위 호환성을 더 쉽게 유지할 수 있고 리더와 팔로워에서 다른 버전의 데이터베이스 소프트웨어나 심지어 다른 저장소 엔진을 실행할 수 있다.

또한 논리적 로그 형식은 외부 애플리케이션이 파싱하기 더 쉽다. 이런 측면은 오프라인 분석이나 사용자 정의 색인과 캐시 구축을 위해 데이터 웨어하우스 같은 외부 시스템에 데이터베이스의 내용을 전송하고자 할 때 유용하다. 이 기술을 변경 데이터 캡처(change data capture. CDC)라 부르며 11장에서 설명한다. ← 일반적으로 카프카 플러그인을 사용해서 구현

### 트리거 기반 복제

지금까지 설명한 복제 접근 방식은 애플리케이션 코드의 사용 없이 데이터베이스 시스템에 의해 구현된다. 대부분 이 방식을 원하지만 조금 더 유연성이 필요한 몇 가지 상황이 있다. 예를 들어 데이터의 서브셋만 복제하거나 데이터베이스를 다른 종류의 데이터베이스로 복제해야 하거나 충돌 해소로직이 필요하다면 복제를 애플리케이션 층으로 옮겨야 한다.

오라클의 골든게이트 같은 도구는 데이터베이스 로그를 읽어 애플리케이션이 데이터를 변경할 수 있게 한다. 다른 방법으로는 많은 관계형 데이터베이스에서 사용할 수 있는 기능인 트리거나 스토어드 프로시저를 사용한다.

트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 한다. 이 애플리케이션 코드는 데이터베이스 시스템에서 데이터가 변경되면(쓰기 트랜잭션) 자동으로 실행된다. 트리거는 데이터 변경을 분리된 테이블에 로깅할 수 있는 기회를 가진다. 이 테이블로부터 데이터 변경을 외부 프로세스가 읽을 수 있다. 그러면 외부 프로세스는 필요한 애플리케이션 로직을 적용해 다른 시스템으로 데이터변경을 복제한다. 예를 들어 오라클용 데이터버스와 포스트그레스큐엘용 부카르도가 이와 같이 동작한다.

일반적으로 트리거 기반 복제에는 다른 복제 방식보다 많은 오버헤드가 있다. 이 방식은 데이터베이스에 내장된 복제보다 버그나 제한 사항이 더 많이 발생한다. 그럼에도 트리거 기반 복제는 유연성 떄문에 매우 유용하다.

# 복제 지연 문제

노드 내결함성을 갖추려는 단 한가지 이유는 복제가 필요하기 때문이다.  리더 기반 복제는 모든 쓰기와 단일 노드를 거쳐야 하지만 읽기 전용 질의는 어떤 복제 서버에서도 가능하다. 대부분이 읽기 요청이고 쓰기가 아주 작은 비율로 구성된 작업부하(웹 상의 공통 패턴)라면 많은 팔로워를 만들어 팔로워 간 읽기 요청을 분산하는 매력적인 옵션이 있다. 이 방식을 사용하면 리더의 부하를 없애고 근처 복제 서버에서 읽기 요청을 처리할 수 있게 해준다.

이런 읽기 확장(read-scaling) 아키텍처에서는 간단히 팔로워를 더 추가함으로써 읽기 전용 요청을 처리하기 위한 용량을 늘릴 수 있다.  하지만 이 접근 방식은 실제로는 비동기식 복제에서만 동작한다. 동기식으로 모든 팔로워에 복제를 시도한다면 단일 노드 장애나 네트워크 중단으로 전체 시스템의 쓰기가 불가능해진다.

- 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤처진다면 지난 정보를 볼 수 있다.
- 팔로워가 리더를 따라잡으면 결국 불일치는 해결된다. 이런 효과를 최종적 일관성이라 한다.
- 복제 지연이 길어지면 팔로워가 리더를 따라잡지 못해 문제가 된다.

## 자신이 쓴 내용 읽기

![image.png]({{ "/assets/img/study/books/data-intensive-applications/chapter05/section1-2/image%206.png" | relative_url }})

사용자가 리뷰를 작성했을 때 리뷰를 리더에 저장하고 읽기는 팔로워를 통해서 한다면 자신이 작성한 리뷰가 보이지 않는 현상이 있을 수 있다. 이런 상황에서는 **쓰기 후 읽기 일관성**이 필요하다. 쓰**기 후 읽기 일관성**은 다른 사용자의 갱신은 일정 시간 이후까지 보이지 않을 수 있다. 하지만 사용자 자신의 입력이 올바르게 저장됐음을 보장한다. 구현 방법은 다양하다.

- 사용자가 수정한 내용을 읽을 때는 리더에서 읽는다. 그 밖에는 팔로워에서 읽는다.
- 애플리케이션 내 대부분의 내용을 사용자가 편집할 수 있다면 계속 리더에서 읽어야 한다. 이럴 때는 마지막 갱신 후 1 분 동안은 리더에서 모든 읽기를 수행하도록 한다. 팔로워에서 복제 지연을 모니터링해 리더보다 1분 이상 늦은 모든 팔로워에 대한 질의를 금지할 수 있다.
- 클라이언트는 가장 최근 쓰기의 타임스탬프를 기억할 수 있다. 팔로워가 아직 최신 내용이 아닌 경우에는 다른 복제 서버가 읽기를 처리하거나 팔로워가 따라잡을 때까지 질의를 대기시킬 수 있다.

동일한 사용자가 여러 디바이스로 서비스를 접근할 때 또 다른 문제가 발생한다. 이 경우에는 디바이스 간 쓰기 후 읽기 일관성이 제공돼야 한다.

## 단조 읽기

비동기식 팔로워에서 읽을 때 발생할 수 있는 두 번째 이상 현상은 사용자가 시간이 거꾸로 흐르는 현상을 목격할 수 있다는 것이다.

![image.png]({{ "/assets/img/study/books/data-intensive-applications/chapter05/section1-2/image%207.png" | relative_url }})

단조 읽기(monotonic read)는 이런 종류의 이상 현상이 발생하지 않음을 보장한다. 단조 읽기는 강한 일관성보다는 덜한 보장이지만 최종적 일관성보다는 더 강한 보장이다. 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않는다.

단조 읽기를 달성하는 방법은 각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 것이다.

## 일관된 순서로 읽기

세 번째 복제 지연 이상 현상은 인과성의 위반 우려다. 푼스 씨와 케이크 부인의 짧은 대화를 아래에서 상상해보자.

👱🏻‍♂️ 푼스 씨: 미래에 대해 얼마나 멀리 볼 수 있나요?

👵🏻 케이크 부인: 보통 10초 정도요.

위 두 문장 사이에는 인과성이 있다. 케이크 부인은 푼스 씨의 질문을 듣고 그에 대한 답을 했다. 이제 팔로워를 통해 이 대화를 듣고 있는 제3자 관찰자가 있다고 상상해보자. 케이크 부인이 한 말은 거의 지연없이 팔로워에게 전달됐지만 푼스 씨가 한 말은 아주 긴 복제 지연이 있었다. 

👵🏻 케이크 부인: 보통 10초 정도요.

👱🏻‍♂️ 푼스 씨: 미래에 대해 얼마나 멀리 볼 수 있나요?

관찰자에게는 케이크 부인이 푼스 씨가 물어보기 전에 질문에 대답한 것처럼 보인다.

![image.png]({{ "/assets/img/study/books/data-intensive-applications/chapter05/section1-2/image%208.png" | relative_url }})

이런 이상 현상을 방지하려면 **일관된 순서로 읽기(Consistent Prefix Read)**같은 또 다른 유형의 보장이 필요하다. 

- 일관된 순서로 읽기:  일련의 쓰기가 특정 순서로 발생한다면 이 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장한다.

이는 파티셔닝된 데이터베이스에서 발생하는 특징적인 문제다. 이 문제는 6장에서 설명한다. 데이터베이스가 항상 같은 순서로 쓰기를 적용한다면 읽기는 항상 일관된 순서를 보기 때문에 이런 현상은 일어나지 않는다.

## 복제 지연을 위한 해결책

최종적 일관성  시스템으로 작업할 때 복제 지연이 몇 분이나 몇 시간으로 증가한다면 애플리케이션이 어떻게 동작할지 생각해 볼 가치가 있다. 사용자에게 좋지 않은 경험이라면 쓰기 후 읽기와 같은 강한 보장을 제공하게끔 시스템을 설계해야 한다. 복제가 비동기식으로 동작하지만 동기식으로 동작하는 척 하는 것이 문제 해결 방안이다.

애플리케이션에서 이를 구현하기에는 너무 복잡해서 잘못되기 쉽다. 애플리케이션 개발자가 이런 미묘한 복제 문제를 걱정하지 않고 올바른 작업 수행을 위해 항상 데이터베이스를 신뢰할 수 있다면 훨씬 좋다. 이것이 **트랜잭션**이 있는 이유다. 트랜잭션은 애플리케이션이 더 단순해지기 위해 데이터베이스가 더 강력한 보장을 제공하는 방법이다.

오랫동안 단일 노드 트랜잭션은 존재했다. 하지만 분산 데이터베이스로 전환하는 과정에서 많은 시스템이 트랜잭션을 포기했다. 트랜잭션이 성능과 가용성 측면에서 너무 비싸고 확장 가능 시스템에서는 어쩔 수 없이 최종적 일관성을 사용해야 한다는 주장이 있다. 이는 사실이지만 지나치게 단순화됐다. 7,9장에서 트랜잭션 주제를 다룬다.

다음 빠다는 썹님!

![image.png]({{ "/assets/img/study/books/data-intensive-applications/chapter05/section1-2/0e63f906-60a1-4ddc-972f-ac5af176f6aa.png" | relative_url }})